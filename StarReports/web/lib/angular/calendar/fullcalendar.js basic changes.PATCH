Index: fullcalendar.js
===================================================================
--- fullcalendar.js	(revision 5473)
+++ fullcalendar.js	(working copy)
@@ -2808,7 +2808,7 @@
             );
             if (t.opt('weekMode') == 'fixed') {
                 t.end.add('weeks', 6 - rowCnt);
-                rowCnt = 6;
+                rowCnt = 5;
             }
 
             t.title = calendar.formatDate(t.intervalStart, t.opt('titleFormat'));
@@ -2953,12 +2953,13 @@
         View.call(t, element, calendar, viewName);
         OverlayManager.call(t);
         SelectionManager.call(t);
+        t.daySelectionMousedown = daySelectionMousedown;
         BasicEventRenderer.call(t);
         var opt = t.opt;
         var trigger = t.trigger;
         var renderOverlay = t.renderOverlay;
         var clearOverlays = t.clearOverlays;
-        var daySelectionMousedown = t.daySelectionMousedown;
+        //var daySelectionMousedown = t.daySelectionMousedown;
         var cellToDate = t.cellToDate;
         var dateToCell = t.dateToCell;
         var rangeToSegments = t.rangeToSegments;
@@ -3417,6 +3418,43 @@
             return bodyRows.eq(i);
         }
 
+        function daySelectionMousedown(ev) { // not really a generic manager method, oh well
+            var cellToDate = t.cellToDate;
+            var getIsCellAllDay = t.getIsCellAllDay;
+            var hoverListener = t.getHoverListener();
+            var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
+
+            if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
+                t.unselect(ev);
+                var dates;
+                hoverListener.start(function (cell, origCell) { // TODO: maybe put cellToDate/getIsCellAllDay info in cell
+                    t.clearSelection();
+                    if (cell && getIsCellAllDay(cell)) {
+                        dates = [ cellToDate(origCell), cellToDate(cell) ].sort(dateCompare);
+                        renderSelection(
+                            dates[0],
+                            dates[1].clone().add('days', 1) // make exclusive
+                        );
+                    } else {
+                        dates = null;
+                    }
+                }, ev);
+                $(document).one('mouseup', function (ev) {
+                    hoverListener.stop();
+                    if (dates) {
+                        if (+dates[0] == +dates[1]) {
+                            reportDayClick(dates[0], ev);
+                        }
+                        t.reportSelection(
+                            dates[0],
+                            dates[1].clone().add('days', 1), // make exclusive
+                            ev, 'fullday'
+                        );
+                    }
+                });
+            }
+        }
+
     }
 
     ;
@@ -3432,7 +3470,7 @@
 
 
         // imports
-        DayEventRenderer.call(t);
+        MonthEventRenderer.call(t);
 
 
         function renderEvents(events, modifiedEventId) {
@@ -3452,6 +3490,749 @@
     ;
     ;
 
+    function MonthEventRenderer() {
+        var t = this;
+
+
+        // exports
+        t.renderDayEvents = renderDayEvents;
+        t.draggableDayEvent = draggableDayEvent; // made public so that subclasses can override
+        t.resizableDayEvent = resizableDayEvent; // "
+
+
+        // imports
+        var opt = t.opt;
+        var trigger = t.trigger;
+        var isEventDraggable = t.isEventDraggable;
+        var isEventResizable = t.isEventResizable;
+        var reportEventElement = t.reportEventElement;
+        var eventElementHandlers = t.eventElementHandlers;
+        var showEvents = t.showEvents;
+        var hideEvents = t.hideEvents;
+        var eventDrop = t.eventDrop;
+        var eventResize = t.eventResize;
+        var getRowCnt = t.getRowCnt;
+        var getColCnt = t.getColCnt;
+        var allDayRow = t.allDayRow; // TODO: rename
+        var colLeft = t.colLeft;
+        var colRight = t.colRight;
+        var colContentLeft = t.colContentLeft;
+        var colContentRight = t.colContentRight;
+        var getDaySegmentContainer = t.getDaySegmentContainer;
+        var renderDayOverlay = t.renderDayOverlay;
+        var clearOverlays = t.clearOverlays;
+        var clearSelection = t.clearSelection;
+        var getHoverListener = t.getHoverListener;
+        var rangeToSegments = t.rangeToSegments;
+        var cellToDate = t.cellToDate;
+        var cellToCellOffset = t.cellToCellOffset;
+        var cellOffsetToDayOffset = t.cellOffsetToDayOffset;
+        var dateToDayOffset = t.dateToDayOffset;
+        var dayOffsetToCellOffset = t.dayOffsetToCellOffset;
+        var calendar = t.calendar;
+        var getEventEnd = calendar.getEventEnd;
+
+
+        // Render `events` onto the calendar, attach mouse event handlers, and call the `eventAfterRender` callback for each.
+        // Mouse event will be lazily applied, except if the event has an ID of `modifiedEventId`.
+        // Can only be called when the event container is empty (because it wipes out all innerHTML).
+        function renderDayEvents(events, modifiedEventId) {
+
+            // do the actual rendering. Receive the intermediate "segment" data structures.
+            var segments = _renderDayEvents(
+                events,
+                false, // don't append event elements
+                true // set the heights of the rows
+            );
+
+            // report the elements to the View, for general drag/resize utilities
+            segmentElementEach(segments, function (segment, element) {
+                reportEventElement(segment.event, element);
+            });
+
+            // attach mouse handlers
+            attachHandlers(segments, modifiedEventId);
+
+            // call `eventAfterRender` callback for each event
+            segmentElementEach(segments, function (segment, element) {
+                trigger('eventAfterRender', segment.event, segment.event, element);
+            });
+        }
+
+
+        // Render an event on the calendar, but don't report them anywhere, and don't attach mouse handlers.
+        // Append this event element to the event container, which might already be populated with events.
+        // If an event's segment will have row equal to `adjustRow`, then explicitly set its top coordinate to `adjustTop`.
+        // This hack is used to maintain continuity when user is manually resizing an event.
+        // Returns an array of DOM elements for the event.
+        function renderTempDayEvent(event, adjustRow, adjustTop) {
+
+            // actually render the event. `true` for appending element to container.
+            // Recieve the intermediate "segment" data structures.
+            var segments = _renderDayEvents(
+                [ event ],
+                true, // append event elements
+                false // don't set the heights of the rows
+            );
+
+            var elements = [];
+
+            // Adjust certain elements' top coordinates
+            segmentElementEach(segments, function (segment, element) {
+                if (segment.row === adjustRow) {
+                    element.css('top', adjustTop);
+                }
+                elements.push(element[0]); // accumulate DOM nodes
+            });
+
+            return elements;
+        }
+
+
+        // Render events onto the calendar. Only responsible for the VISUAL aspect.
+        // Not responsible for attaching handlers or calling callbacks.
+        // Set `doAppend` to `true` for rendering elements without clearing the existing container.
+        // Set `doRowHeights` to allow setting the height of each row, to compensate for vertical event overflow.
+        function _renderDayEvents(events, doAppend, doRowHeights) {
+
+            // where the DOM nodes will eventually end up
+            var finalContainer = getDaySegmentContainer();
+
+            // the container where the initial HTML will be rendered.
+            // If `doAppend`==true, uses a temporary container.
+            var renderContainer = doAppend ? $("<div/>") : finalContainer;
+
+            var segments = buildSegments(events);
+            var html;
+            var elements;
+
+            // calculate the desired `left` and `width` properties on each segment object
+            calculateHorizontals(segments);
+
+            // build the HTML string. relies on `left` property
+            html = buildHTML(segments);
+
+            // render the HTML. innerHTML is considerably faster than jQuery's .html()
+            renderContainer[0].innerHTML = html;
+
+            // retrieve the individual elements
+            elements = renderContainer.children();
+
+            // if we were appending, and thus using a temporary container,
+            // re-attach elements to the real container.
+            if (doAppend) {
+                finalContainer.append(elements);
+            }
+
+            // assigns each element to `segment.event`, after filtering them through user callbacks
+            resolveElements(segments, elements);
+
+            // Calculate the left and right padding+margin for each element.
+            // We need this for setting each element's desired outer width, because of the W3C box model.
+            // It's important we do this in a separate pass from acually setting the width on the DOM elements
+            // because alternating reading/writing dimensions causes reflow for every iteration.
+            segmentElementEach(segments, function (segment, element) {
+                segment.hsides = hsides(element, true); // include margins = `true`
+            });
+
+            // Set the width of each element
+            segmentElementEach(segments, function (segment, element) {
+                element.width(
+                    Math.max(0, segment.outerWidth - segment.hsides)
+                );
+            });
+
+            // Grab each element's outerHeight (setVerticals uses this).
+            // To get an accurate reading, it's important to have each element's width explicitly set already.
+            segmentElementEach(segments, function (segment, element) {
+                segment.outerHeight = element.outerHeight(true); // include margins = `true`
+            });
+
+            // Set the top coordinate on each element (requires segment.outerHeight)
+            setVerticals(segments, doRowHeights);
+
+            return segments;
+        }
+
+
+        // Generate an array of "segments" for all events.
+        function buildSegments(events) {
+            var segments = [];
+            for (var i = 0; i < events.length; i++) {
+                var eventSegments = buildSegmentsForEvent(events[i]);
+                segments.push.apply(segments, eventSegments); // append an array to an array
+            }
+            return segments;
+        }
+
+
+        // Generate an array of segments for a single event.
+        // A "segment" is the same data structure that View.rangeToSegments produces,
+        // with the addition of the `event` property being set to reference the original event.
+        function buildSegmentsForEvent(event) {
+            var segments = rangeToSegments(event.start, getEventEnd(event));
+            for (var i = 0; i < segments.length; i++) {
+                segments[i].event = event;
+            }
+            return segments;
+        }
+
+
+        // Sets the `left` and `outerWidth` property of each segment.
+        // These values are the desired dimensions for the eventual DOM elements.
+        function calculateHorizontals(segments) {
+            var isRTL = opt('isRTL');
+            for (var i = 0; i < segments.length; i++) {
+                var segment = segments[i];
+
+                // Determine functions used for calulating the elements left/right coordinates,
+                // depending on whether the view is RTL or not.
+                // NOTE:
+                // colLeft/colRight returns the coordinate butting up the edge of the cell.
+                // colContentLeft/colContentRight is indented a little bit from the edge.
+                var leftFunc = (isRTL ? segment.isEnd : segment.isStart) ? colContentLeft : colLeft;
+                var rightFunc = (isRTL ? segment.isStart : segment.isEnd) ? colContentRight : colRight;
+
+                var left = leftFunc(segment.leftCol);
+                var right = rightFunc(segment.rightCol);
+                segment.left = left;
+                segment.outerWidth = right - left;
+            }
+        }
+
+
+        // Build a concatenated HTML string for an array of segments
+        function buildHTML(segments) {
+            var html = '';
+            for (var i = 0; i < segments.length; i++) {
+                html += buildHTMLForSegment(segments[i]);
+            }
+            return html;
+        }
+
+
+        // Build an HTML string for a single segment.
+        // Relies on the following properties:
+        // - `segment.event` (from `buildSegmentsForEvent`)
+        // - `segment.left` (from `calculateHorizontals`)
+        function buildHTMLForSegment(segment) {
+            var html = '';
+            var isRTL = opt('isRTL');
+            var event = segment.event;
+            var url = event.url;
+
+            // generate the list of CSS classNames
+            var classNames = [ 'fc-event', 'fc-event-hori' ];
+            if (isEventDraggable(event)) {
+                classNames.push('fc-event-draggable');
+            }
+            if (segment.isStart) {
+                classNames.push('fc-event-start');
+            }
+            if (segment.isEnd) {
+                classNames.push('fc-event-end');
+            }
+            // use the event's configured classNames
+            // guaranteed to be an array via `buildEvent`
+            classNames = classNames.concat(event.className);
+            if (event.source) {
+                // use the event's source's classNames, if specified
+                classNames = classNames.concat(event.source.className || []);
+            }
+
+            // generate a semicolon delimited CSS string for any of the "skin" properties
+            // of the event object (`backgroundColor`, `borderColor` and such)
+            var skinCss = getSkinCss(event, opt);
+
+            if (url) {
+                html += "<a href='" + htmlEscape(url) + "'";
+            } else {
+                html += "<div";
+            }
+            html +=
+                " class='" + classNames.join(' ') + "'" +
+                    " style=" +
+                    "'" +
+                    "position:absolute;" +
+                    "left:" + segment.left + "px;" +
+                    skinCss +
+                    "'" +
+                    ">" +
+                    "<div class='fc-event-inner'>";
+            if (!event.allDay && segment.isStart) {
+                html +=
+                    "<span class='fc-event-time'>" +
+                        htmlEscape(t.getEventTimeText(event)) +
+                        "</span>";
+            }
+            html +=
+                "<span class='fc-event-title'>" +
+                    htmlEscape(event.title || '') +
+                    "</span>" +
+                    "</div>";
+            if (event.allDay && segment.isEnd && isEventResizable(event)) {
+                html +=
+                    "<div class='ui-resizable-handle ui-resizable-" + (isRTL ? 'w' : 'e') + "'>" +
+                        "&nbsp;&nbsp;&nbsp;" + // makes hit area a lot better for IE6/7
+                        "</div>";
+            }
+            html += "</" + (url ? "a" : "div") + ">";
+
+            // TODO:
+            // When these elements are initially rendered, they will be briefly visibile on the screen,
+            // even though their widths/heights are not set.
+            // SOLUTION: initially set them as visibility:hidden ?
+
+            return html;
+        }
+
+
+        // Associate each segment (an object) with an element (a jQuery object),
+        // by setting each `segment.element`.
+        // Run each element through the `eventRender` filter, which allows developers to
+        // modify an existing element, supply a new one, or cancel rendering.
+        function resolveElements(segments, elements) {
+            for (var i = 0; i < segments.length; i++) {
+                var segment = segments[i];
+                var event = segment.event;
+                var element = elements.eq(i);
+
+                // call the trigger with the original element
+                var triggerRes = trigger('eventRender', event, event, element);
+
+                if (triggerRes === false) {
+                    // if `false`, remove the event from the DOM and don't assign it to `segment.event`
+                    element.remove();
+                }
+                else {
+                    if (triggerRes && triggerRes !== true) {
+                        // the trigger returned a new element, but not `true` (which means keep the existing element)
+
+                        // re-assign the important CSS dimension properties that were already assigned in `buildHTMLForSegment`
+                        triggerRes = $(triggerRes)
+                            .css({
+                                position: 'absolute',
+                                left: segment.left
+                            });
+
+                        element.replaceWith(triggerRes);
+                        element = triggerRes;
+                    }
+
+                    segment.element = element;
+                }
+            }
+        }
+
+
+        /* Top-coordinate Methods
+         -------------------------------------------------------------------------------------------------*/
+
+
+        // Sets the "top" CSS property for each element.
+        // If `doRowHeights` is `true`, also sets each row's first cell to an explicit height,
+        // so that if elements vertically overflow, the cell expands vertically to compensate.
+        function setVerticals(segments, doRowHeights) {
+            var rowContentHeights = calculateVerticals(segments); // also sets segment.top
+            var rowContentElements = getRowContentElements(); // returns 1 inner div per row
+            var rowContentTops = [];
+            var i;
+
+            // Set each row's height by setting height of first inner div
+            if (doRowHeights) {
+                for (i = 0; i < rowContentElements.length; i++) {
+                    rowContentElements[i].height(rowContentHeights[i]);
+                }
+            }
+
+            // Get each row's top, relative to the views's origin.
+            // Important to do this after setting each row's height.
+            for (i = 0; i < rowContentElements.length; i++) {
+                rowContentTops.push(
+                    rowContentElements[i].position().top
+                );
+            }
+
+            // Set each segment element's CSS "top" property.
+            // Each segment object has a "top" property, which is relative to the row's top, but...
+            segmentElementEach(segments, function (segment, element) {
+                element.css(
+                    'top',
+                    rowContentTops[segment.row] + segment.top // ...now, relative to views's origin
+                );
+            });
+        }
+
+
+        // Calculate the "top" coordinate for each segment, relative to the "top" of the row.
+        // Also, return an array that contains the "content" height for each row
+        // (the height displaced by the vertically stacked events in the row).
+        // Requires segments to have their `outerHeight` property already set.
+        function calculateVerticals(segments) {
+            var rowCnt = getRowCnt();
+            var colCnt = getColCnt();
+            var rowContentHeights = []; // content height for each row
+            var segmentRows = buildSegmentRows(segments); // an array of segment arrays, one for each row
+            var colI;
+
+            for (var rowI = 0; rowI < rowCnt; rowI++) {
+                var segmentRow = segmentRows[rowI];
+
+                // an array of running total heights for each column.
+                // initialize with all zeros.
+                var colHeights = [];
+                for (colI = 0; colI < colCnt; colI++) {
+                    colHeights.push(0);
+                }
+
+                // loop through every segment
+                for (var segmentI = 0; segmentI < segmentRow.length; segmentI++) {
+                    var segment = segmentRow[segmentI];
+
+                    // find the segment's top coordinate by looking at the max height
+                    // of all the columns the segment will be in.
+                    segment.top = arrayMax(
+                        colHeights.slice(
+                            segment.leftCol,
+                            segment.rightCol + 1 // make exclusive for slice
+                        )
+                    );
+
+                    // adjust the columns to account for the segment's height
+                    for (colI = segment.leftCol; colI <= segment.rightCol; colI++) {
+                        colHeights[colI] = segment.top + segment.outerHeight;
+                    }
+                }
+
+                // the tallest column in the row should be the "content height"
+                rowContentHeights.push(arrayMax(colHeights));
+            }
+
+            return rowContentHeights;
+        }
+
+
+        // Build an array of segment arrays, each representing the segments that will
+        // be in a row of the grid, sorted by which event should be closest to the top.
+        function buildSegmentRows(segments) {
+            var rowCnt = getRowCnt();
+            var segmentRows = [];
+            var segmentI;
+            var segment;
+            var rowI;
+
+            // group segments by row
+            for (segmentI = 0; segmentI < segments.length; segmentI++) {
+                segment = segments[segmentI];
+                rowI = segment.row;
+                if (segment.element) { // was rendered?
+                    if (segmentRows[rowI]) {
+                        // already other segments. append to array
+                        segmentRows[rowI].push(segment);
+                    }
+                    else {
+                        // first segment in row. create new array
+                        segmentRows[rowI] = [ segment ];
+                    }
+                }
+            }
+
+            // sort each row
+            for (rowI = 0; rowI < rowCnt; rowI++) {
+                segmentRows[rowI] = sortSegmentRow(
+                    segmentRows[rowI] || [] // guarantee an array, even if no segments
+                );
+            }
+
+            return segmentRows;
+        }
+
+
+        // Sort an array of segments according to which segment should appear closest to the top
+        function sortSegmentRow(segments) {
+            var sortedSegments = [];
+
+            // build the subrow array
+            var subrows = buildSegmentSubrows(segments);
+
+            // flatten it
+            for (var i = 0; i < subrows.length; i++) {
+                sortedSegments.push.apply(sortedSegments, subrows[i]); // append an array to an array
+            }
+
+            return sortedSegments;
+        }
+
+
+        // Take an array of segments, which are all assumed to be in the same row,
+        // and sort into subrows.
+        function buildSegmentSubrows(segments) {
+
+            // Give preference to elements with certain criteria, so they have
+            // a chance to be closer to the top.
+            segments.sort(compareDaySegments);
+
+            var subrows = [];
+            for (var i = 0; i < segments.length; i++) {
+                var segment = segments[i];
+
+                // loop through subrows, starting with the topmost, until the segment
+                // doesn't collide with other segments.
+                for (var j = 0; j < subrows.length; j++) {
+                    if (!isDaySegmentCollision(segment, subrows[j])) {
+                        break;
+                    }
+                }
+                // `j` now holds the desired subrow index
+                if (subrows[j]) {
+                    subrows[j].push(segment);
+                }
+                else {
+                    subrows[j] = [ segment ];
+                }
+            }
+
+            return subrows;
+        }
+
+
+        // Return an array of jQuery objects for the placeholder content containers of each row.
+        // The content containers don't actually contain anything, but their dimensions should match
+        // the events that are overlaid on top.
+        function getRowContentElements() {
+            var i;
+            var rowCnt = getRowCnt();
+            var rowDivs = [];
+            for (i = 0; i < rowCnt; i++) {
+                rowDivs[i] = allDayRow(i)
+                    .find('div.fc-day-content > div');
+            }
+            return rowDivs;
+        }
+
+
+        /* Mouse Handlers
+         ---------------------------------------------------------------------------------------------------*/
+        // TODO: better documentation!
+
+
+        function attachHandlers(segments, modifiedEventId) {
+            var segmentContainer = getDaySegmentContainer();
+
+            segmentElementEach(segments, function (segment, element, i) {
+                var event = segment.event;
+                if (event._id === modifiedEventId) {
+                    bindDaySeg(event, element, segment);
+                } else {
+                    element[0]._fci = i; // for lazySegBind
+                }
+            });
+
+            lazySegBind(segmentContainer, segments, bindDaySeg);
+        }
+
+
+        function bindDaySeg(event, eventElement, segment) {
+
+            if (isEventDraggable(event)) {
+                t.draggableDayEvent(event, eventElement, segment); // use `t` so subclasses can override
+            }
+
+            if (
+                event.allDay &&
+                    segment.isEnd && // only allow resizing on the final segment for an event
+                    isEventResizable(event)
+                ) {
+                t.resizableDayEvent(event, eventElement, segment); // use `t` so subclasses can override
+            }
+
+            // attach all other handlers.
+            // needs to be after, because resizableDayEvent might stopImmediatePropagation on click
+            eventElementHandlers(event, eventElement);
+        }
+
+
+        function draggableDayEvent(event, eventElement) {
+            var hoverListener = getHoverListener();
+            var dayDelta;
+            var eventStart;
+            eventElement.draggable({
+                delay: 50,
+                opacity: opt('dragOpacity'),
+                revertDuration: opt('dragRevertDuration'),
+                start: function (ev, ui) {
+                    trigger('eventDragStart', eventElement[0], event, ev, ui);
+                    hideEvents(event, eventElement);
+                    hoverListener.start(function (cell, origCell, rowDelta, colDelta) {
+                        eventElement.draggable('option', 'revert', !cell || !rowDelta && !colDelta);
+                        clearOverlays();
+                        if (cell) {
+                            var origCellDate = cellToDate(origCell);
+                            var cellDate = cellToDate(cell);
+                            dayDelta = cellDate.diff(origCellDate, 'days');
+                            eventStart = event.start.clone().add('days', dayDelta);
+                            renderDayOverlay(
+                                eventStart,
+                                getEventEnd(event).add('days', dayDelta)
+                            );
+                        }
+                        else {
+                            dayDelta = 0;
+                        }
+                    }, ev, 'drag');
+                },
+                stop: function (ev, ui) {
+                    hoverListener.stop();
+                    clearOverlays();
+                    trigger('eventDragStop', eventElement[0], event, ev, ui);
+                    if (dayDelta) {
+                        eventDrop(
+                            eventElement[0],
+                            event,
+                            eventStart,
+                            ev,
+                            ui
+                        );
+                    }
+                    else {
+                        eventElement.css('filter', ''); // clear IE opacity side-effects
+                        showEvents(event, eventElement);
+                    }
+                }
+            });
+        }
+
+
+        function resizableDayEvent(event, element, segment) {
+            var isRTL = opt('isRTL');
+            var direction = isRTL ? 'w' : 'e';
+            var handle = element.find('.ui-resizable-' + direction); // TODO: stop using this class because we aren't using jqui for this
+            var isResizing = false;
+
+            // TODO: look into using jquery-ui mouse widget for this stuff
+            disableTextSelection(element); // prevent native <a> selection for IE
+            element
+                .mousedown(function (ev) { // prevent native <a> selection for others
+                    ev.preventDefault();
+                })
+                .click(function (ev) {
+                    if (isResizing) {
+                        ev.preventDefault(); // prevent link from being visited (only method that worked in IE6)
+                        ev.stopImmediatePropagation(); // prevent fullcalendar eventClick handler from being called
+                        // (eventElementHandlers needs to be bound after resizableDayEvent)
+                    }
+                });
+
+            handle.mousedown(function (ev) {
+                if (ev.which != 1) {
+                    return; // needs to be left mouse button
+                }
+                isResizing = true;
+                var hoverListener = getHoverListener();
+                var elementTop = element.css('top');
+                var dayDelta;
+                var eventEnd;
+                var helpers;
+                var eventCopy = $.extend({}, event);
+                var minCellOffset = dayOffsetToCellOffset(dateToDayOffset(event.start));
+                clearSelection();
+                $('body')
+                    .css('cursor', direction + '-resize')
+                    .one('mouseup', mouseup);
+                trigger('eventResizeStart', element[0], event, ev, {}); // {} is dummy jqui event
+                hoverListener.start(function (cell, origCell) {
+                    if (cell) {
+
+                        var origCellOffset = cellToCellOffset(origCell);
+                        var cellOffset = cellToCellOffset(cell);
+
+                        // don't let resizing move earlier than start date cell
+                        cellOffset = Math.max(cellOffset, minCellOffset);
+
+                        dayDelta =
+                            cellOffsetToDayOffset(cellOffset) -
+                                cellOffsetToDayOffset(origCellOffset);
+
+                        eventEnd = getEventEnd(event).add('days', dayDelta); // assumed to already have a stripped time
+
+                        if (dayDelta) {
+                            eventCopy.end = eventEnd;
+                            var oldHelpers = helpers;
+                            helpers = renderTempDayEvent(eventCopy, segment.row, elementTop);
+                            helpers = $(helpers); // turn array into a jQuery object
+                            helpers.find('*').css('cursor', direction + '-resize');
+                            if (oldHelpers) {
+                                oldHelpers.remove();
+                            }
+                            hideEvents(event);
+                        }
+                        else {
+                            if (helpers) {
+                                showEvents(event);
+                                helpers.remove();
+                                helpers = null;
+                            }
+                        }
+
+                        clearOverlays();
+                        renderDayOverlay( // coordinate grid already rebuilt with hoverListener.start()
+                            event.start,
+                            eventEnd
+                            // TODO: instead of calling renderDayOverlay() with dates,
+                            // call _renderDayOverlay (or whatever) with cell offsets.
+                        );
+                    }
+                }, ev);
+
+                function mouseup(ev) {
+                    trigger('eventResizeStop', element[0], event, ev, {}); // {} is dummy jqui event
+                    $('body').css('cursor', '');
+                    hoverListener.stop();
+                    clearOverlays();
+
+                    if (dayDelta) {
+                        eventResize(
+                            element[0],
+                            event,
+                            eventEnd,
+                            ev,
+                            {} // dummy jqui event
+                        );
+                        // event redraw will clear helpers
+                    }
+                    // otherwise, the drag handler already restored the old events
+
+                    setTimeout(function () { // make this happen after the element's click event
+                        isResizing = false;
+                    }, 0);
+                }
+            });
+        }
+
+        t.getEventTimeText = function (event) {
+            var start;
+            var end;
+
+            if (arguments.length === 2) {
+                start = arguments[0];
+                end = arguments[1];
+            }
+            else {
+                start = event.start;
+                end = event.end;
+            }
+
+            if (end && opt('displayEventEnd')) {
+                return calendar.formatRange(start, end, opt('timeFormat'));
+            }
+            else {
+                return calendar.formatDate(start, opt('timeFormat'));
+            }
+        };
+
+
+    }
+
     fcViews.agendaWeek = AgendaWeekView;
 
     function AgendaWeekView(element, calendar) { // TODO: do a WeekView mixin
@@ -3508,7 +4289,7 @@
 
 
         // imports
-        AgendaView.call(t, element, calendar, 'agendaDay');
+        DailyView.call(t, element, calendar, 'agendaDay');
 
 
         function incrementDate(date, delta) {
@@ -3525,7 +4306,7 @@
 
             t.title = calendar.formatDate(t.start, t.opt('titleFormat'));
 
-            t.renderAgenda(1);
+            t.renderDailyView(1);
         }
 
 
@@ -3534,6 +4315,59 @@
     ;
     ;
 
+    fcViews.twoWeekly = TwoWeeklyView;
+
+    function TwoWeeklyView(element, calendar) {
+        var t = this;
+
+
+        // exports
+        t.incrementDate = incrementDate;
+        t.render = render;
+
+
+        // imports
+        BasicView.call(t, element, calendar, 'twoWeekly');
+
+
+        function incrementDate(date, delta) {
+            return date.clone().stripTime().add('weeks', 2).startOf('week');
+        }
+
+
+        function render(date) {
+
+            t.intervalStart = date.clone().stripTime().startOf('week');
+            t.intervalEnd = t.intervalStart.clone().add('weeks', 2);
+
+            t.start = t.skipHiddenDays(t.intervalStart);
+            t.end = t.skipHiddenDays(t.intervalEnd, -1, true);
+
+            var rowCnt = Math.ceil( // need to ceil in case there are hidden days
+                t.end.diff(t.start, 'weeks', true) // returnfloat=true
+            );
+            if (t.opt('weekMode') == 'fixed') {
+                //t.end.add('weeks', 1);
+                rowCnt = 2;
+            }
+
+            //t.title = calendar.formatDate(t.intervalStart, t.opt('titleFormat'));
+            t.title = calendar.formatRange(
+                t.start,
+                t.end.clone().subtract(1), // make inclusive by subtracting 1 ms
+                t.opt('titleFormat'),
+                ' \u2014 '
+            );
+
+            t.renderBasic(rowCnt, t.getCellsPerWeek(), true);
+        }
+
+
+    }
+
+    ;
+    ;
+
     setDefaults({
         allDaySlot: true,
         allDayText: 'all-day',
@@ -3608,7 +4442,7 @@
             return slotContainer;
         };
         t.getRowCnt = function () {
-            return 1;
+            return allDayRow.length;
         };
         t.getColCnt = function () {
             return colCnt;
@@ -3641,6 +4475,10 @@
         t.reportDayClick = reportDayClick; // selection mousedown hack
         t.dragStart = dragStart;
         t.dragStop = dragStop;
+        t.setLevelValues = setLevelValues;
+        t.setLevelDetails = setLevelDetails;
+        t.getFullDayCount = getFullDayCount;
+        t.getLevelCount = getLevelCount;
 
 
         // imports
@@ -3715,7 +4553,76 @@
         /* Rendering
          -----------------------------------------------------------------------------*/
 
+        function setLevelValues(eventSegments, allDayLevelDetails) {
+            var dateStr = eventSegments[0].event.start.format("YYYY-MM-DD");
+            var levelObj = allDayLevelDetails[eventSegments[0].row][dateStr];
+            var seg = eventSegments[0];
+            var allDay = seg.event.allDay;
+            seg.fullDayCount = levelObj.fullDayCount;
+            seg.levelCount = levelObj.levelCount;
+            seg.level = levelObj.level;
+            seg.fullDayLevel = levelObj.fullDayLevel;
+            if (allDay == 'am' || allDay == 'pm') {
+                levelObj.level += 1;
+            } else {
+                levelObj.fullDayLevel += 1;
+            }
+            eventSegments[0] = seg;
+            return eventSegments;
+        }
 
+        function setLevelDetails(events) {
+            var levelDetails = [];
+            for (var row = 0; row < 2; row++) {
+                levelDetails[row] = [];
+                levelDetails[row] = [];
+                for (var j = 0; j < events.length; j++) {
+                    var dateString = events[j].start.format("YYYY-MM-DD");
+                    if (typeof levelDetails[row][dateString] != "undefined") {
+                        if (events[j].allDay == 'fullday' || (row == 0 && events[j].allDay == 'am') || (row == 1 && events[j].allDay == 'pm')) {
+                            var levelCount = levelDetails[row][dateString].levelCount + 1;
+                            var fullDayCount = levelDetails[row][dateString].fullDayCount;
+                            levelDetails[row][dateString] = {levelCount: levelCount, level: 0, fullDayCount: fullDayCount, fullDayLevel: 0};
+                        }
+                        continue;
+                    } else {
+                        if (events[j].allDay == 'fullday' || (row == 0 && events[j].allDay == 'am') || (row == 1 && events[j].allDay == 'pm')) {
+                            var fullDayCount = getFullDayCount(dateString, events);
+                            var levelCnt = 1;
+                            if (events[j].allDay == 'fullday') {
+                                levelCnt = 0
+                            }
+                            levelDetails[row][dateString] = {levelCount: levelCnt, level: 0, fullDayCount: fullDayCount, fullDayLevel: 0};
+                        }
+                    }
+                }
+            }
+            allDayLevelDetails = levelDetails;
+            return allDayLevelDetails;
+        }
+
+        function getFullDayCount(dateString, events) {
+            var count = 0;
+            for (var i = 0; i < events.length; i++) {
+                var eventDate = events[i].start.format("YYYY-MM-DD");
+                if (eventDate == dateString && events[i].allDay == 'fullday') {
+                    count++;
+                }
+            }
+            return count;
+        }
+
+        function getLevelCount(event, allDayLevelDetails) {
+            var count = 0;
+            var eventDate = event.start.format("YYYY-MM-DD");
+            if (allDayLevelDetails[0][eventDate].levelCount > allDayLevelDetails[1][eventDate].levelCount) {
+                count = allDayLevelDetails[0][eventDate].levelCount;
+            } else {
+                count = allDayLevelDetails[1][eventDate].levelCount;
+            }
+            return count;
+        }
+
         disableTextSelection(element.addClass('fc-agenda'));
 
 
@@ -3775,22 +4682,26 @@
                 s =
                     "<table style='width:100%' class='fc-agenda-allday' cellspacing='0'>" +
                         "<tr>" +
-                        "<th class='" + headerClass + " fc-agenda-axis'>" +
-                        (
-                            opt('allDayHTML') ||
-                                htmlEscape(opt('allDayText'))
-                            ) +
-                        "</th>" +
+                        "<th class='" + headerClass + " fc-agenda-axis'>am</th>" +
                         "<td>" +
                         "<div class='fc-day-content'><div style='position:relative'/></div>" +
                         "</td>" +
                         "<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
                         "</tr>" +
+                        "<tr>" +
+                        "<th class='" + headerClass + " fc-agenda-axis'>pm</th>" +
+                        "<td>" +
+                        "<div class='fc-day-content'><div style='position:relative'/></div>" +
+                        "</td>" +
+                        "<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
+                        "</tr>" +
                         "</table>";
                 allDayTable = $(s).appendTo(slotLayer);
                 allDayRow = allDayTable.find('tr');
 
-                dayBind(allDayRow.find('td'));
+                for (var rowCount = 0; rowCount < allDayRow.length; rowCount++) {
+                    dayBind($(allDayRow[rowCount]).find('td'));
+                }
 
                 slotLayer.append(
                     "<div class='fc-agenda-divider " + headerClass + "'>" +
@@ -4157,7 +5068,7 @@
         // TODO: should be consolidated with BasicView's methods
 
 
-        function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive
+        function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid, cells) { // overlayEnd is exclusive
 
             if (refreshCoordinateGrid) {
                 coordinateGrid.build();
@@ -4165,13 +5076,26 @@
 
             var segments = rangeToSegments(overlayStart, overlayEnd);
 
+            var row1, row2;
+            if (cells[0].row == cells[1].row) {
+                row1 = row2 = cells[0].row;
+            } else {
+                if (cells[0].row > cells[1].row) {
+                    row1 = cells[1].row;
+                    row2 = cells[0].row;
+                } else {
+                    row1 = cells[0].row;
+                    row2 = cells[1].row;
+                }
+            }
+
             for (var i = 0; i < segments.length; i++) {
                 var segment = segments[i];
                 dayBind(
                     renderCellOverlay(
-                        segment.row,
+                        row1,
                         segment.leftCol,
-                        segment.row,
+                        row2,
                         segment.rightCol
                     )
                 );
@@ -4232,8 +5156,10 @@
             p[1] = n + e.outerWidth();
             if (opt('allDaySlot')) {
                 e = allDayRow;
-                n = e.offset().top;
-                rows[0] = [n, n + e.outerHeight()];
+                for (var allDayRowCount = 0; allDayRowCount < e.length; allDayRowCount++) {
+                    n = $(e[allDayRowCount]).offset().top;
+                    rows[allDayRowCount] = [n, n + e.outerHeight()];
+                }
             }
             var slotTableTop = slotContainer.offset().top;
             var slotScrollerTop = slotScroller.offset().top;
@@ -4287,7 +5213,7 @@
 
 
         function getIsCellAllDay(cell) { // TODO: remove because mom.hasTime() from realCellToDate() is better
-            return opt('allDaySlot') && !cell.row;
+            return opt('allDaySlot') && (cell.row == 0 || cell.row == 1);
         }
 
 
@@ -4296,7 +5222,7 @@
             var snapIndex = cell.row;
 
             if (opt('allDaySlot')) {
-                snapIndex--;
+                snapIndex = snapIndex - 2;
             }
 
             if (snapIndex >= 0) {
@@ -4365,12 +5291,12 @@
         }
 
 
-        function renderSelection(start, end) {
+        function renderSelection(start, end, cells) {
             if (start.hasTime() || end.hasTime()) {
                 renderSlotSelection(start, end);
             }
             else if (opt('allDaySlot')) {
-                renderDayOverlay(start, end, true); // true for refreshing coordinate grid
+                renderDayOverlay(start, end, true, cells); // true for refreshing coordinate grid
             }
         }
 
@@ -4943,11 +5869,11 @@
                             var date = cellToDate(0, cell.col);
                             dayDelta = date.diff(origDate, 'days');
 
-                            if (!cell.row) { // on full-days
+                            if (cell.row == 0 || cell.row == 1) { // on full-days
 
                                 renderDayOverlay(
                                     event.start.clone().add('days', dayDelta),
-                                    getEventEnd(event).add('days', dayDelta)
+                                    getEventEnd(event).add('days', dayDelta), true, [cell, cell]
                                 );
 
                                 resetElement();
@@ -4955,7 +5881,7 @@
                             else { // mouse is over bottom slots
 
                                 if (isStart) {
-                                    if (allDay) {
+                                    if (cell.row != 1 && cell.row != 0) {
                                         // convert event to temporary slot-event
                                         eventElement.width(colWidth - 10); // don't use entire width
                                         setOuterHeight(eventElement, calendar.defaultTimedEventDuration / slotDuration * slotHeight); // the default height
@@ -4968,7 +5894,7 @@
                                 }
                             }
 
-                            revert = revert || (allDay && !dayDelta);
+                            revert = revert;// || (allDay && !dayDelta);
                         }
                         else {
                             resetElement();
@@ -4980,7 +5906,7 @@
                     }, ev, 'drag');
                 },
                 stop: function (ev, ui) {
-                    hoverListener.stop();
+                    var cell = hoverListener.stop();
                     clearOverlays();
                     trigger('eventDragStop', eventElement, event, ev, ui);
 
@@ -4995,6 +5921,16 @@
                         var eventStart = event.start.clone().add('days', dayDelta); // already assumed to have a stripped time
                         var snapTime;
                         var snapIndex;
+                        if (event.allDay != 'fullday' && allDay) {
+                            var allDayVal;
+                            if (cell.row) {
+                                allDayVal = 'pm';
+                            } else {
+                                allDayVal = 'am';
+                            }
+                            event._allDay = true;
+                            event.allDay = allDayVal;
+                        }
                         if (!allDay) {
                             snapIndex = Math.round((eventElement.offset().top - getSlotContainer().offset().top) / snapHeight); // why not use ui.offset.top?
                             snapTime = moment.duration(minTime + snapIndex * snapDuration);
@@ -5043,6 +5979,7 @@
 
             // newly computed
             var eventStart, eventEnd;
+            var cell;
 
             eventElement.draggable({
                 scroll: false,
@@ -5077,7 +6014,7 @@
                     //
                     // PS- the problem exists for draggableDayEvent() when dragging an all-day event to a slot event.
                     // We should overhaul the dragging system and stop relying on jQuery UI.
-                    var cell = coordinateGrid.cell(ev.pageX, ev.pageY);
+                    cell = coordinateGrid.cell(ev.pageX, ev.pageY);
 
                     // update states
                     isInBounds = !!cell;
@@ -5120,7 +6057,7 @@
                             eventEnd = getEventEnd(event).add(snapDelta * snapDuration).add('days', dayDelta);
                         }
 
-                        updateUI();
+                        updateUI(cell);
 
                         // update previous states for next time
                         prevIsInBounds = isInBounds;
@@ -5136,6 +6073,18 @@
                 stop: function (ev, ui) {
 
                     clearOverlays();
+                    if (cell) {
+                        if (cell.row == 0 || cell.row == 1) {
+                            var allDayVal = false;
+                            if (cell.row) {
+                                allDayVal = 'pm';
+                            } else {
+                                allDayVal = 'am';
+                            }
+                            event._allDay = true;
+                            event.allDay = allDayVal;
+                        }
+                    }
                     trigger('eventDragStop', eventElement, event, ev, ui);
 
                     if (isInBounds && (isAllDay || dayDelta || snapDelta)) { // changed!
@@ -5156,7 +6105,1958 @@
                         dayDelta = 0;
                         snapDelta = 0;
 
+                        updateUI(cell);
+                        eventElement.css('filter', ''); // clear IE opacity side-effects
+
+                        // sometimes fast drags make event revert to wrong position, so reset.
+                        // also, if we dragged the element out of the area because of snapping,
+                        // but the *mouse* is still in bounds, we need to reset the position.
+                        eventElement.css(origPosition);
+
+                        showEvents(event, eventElement);
+                    }
+                }
+            });
+
+            function updateUI(cell) {
+                clearOverlays();
+                if (isInBounds) {
+                    if (isAllDay) {
+                        timeElement.hide();
+                        eventElement.draggable('option', 'grid', null); // disable grid snapping
+                        renderDayOverlay(eventStart, eventEnd, true, [cell, cell]);
+                    }
+                    else {
+                        updateTimeText();
+                        timeElement.css('display', ''); // show() was causing display=inline
+                        eventElement.draggable('option', 'grid', [colWidth, snapHeight]); // re-enable grid snapping
+                    }
+                }
+            }
+
+            function updateTimeText() {
+                var text;
+                if (eventStart) { // must of had a state change
+                    if (event.end) {
+                        text = formatRange(eventStart, eventEnd, opt('timeFormat'));
+                    }
+                    else {
+                        text = formatDate(eventStart, opt('timeFormat'));
+                    }
+                    timeElement.text(text);
+                }
+            }
+
+        }
+
+
+        /* Resizing
+         --------------------------------------------------------------------------------------*/
+
+
+        function resizableSlotEvent(event, eventElement, timeElement) {
+            var snapDelta, prevSnapDelta;
+            var snapHeight = getSnapHeight();
+            var snapDuration = getSnapDuration();
+            var eventEnd;
+
+            eventElement.resizable({
+                handles: {
+                    s: '.ui-resizable-handle'
+                },
+                grid: snapHeight,
+                start: function (ev, ui) {
+                    snapDelta = prevSnapDelta = 0;
+                    hideEvents(event, eventElement);
+                    trigger('eventResizeStart', this, event, ev, ui);
+                },
+                resize: function (ev, ui) {
+                    // don't rely on ui.size.height, doesn't take grid into account
+                    snapDelta = Math.round((Math.max(snapHeight, eventElement.height()) - ui.originalSize.height) / snapHeight);
+                    if (snapDelta != prevSnapDelta) {
+                        eventEnd = getEventEnd(event).add(snapDuration * snapDelta);
+                        var text;
+                        if (snapDelta || event.end) {
+                            text = formatRange(
+                                event.start,
+                                eventEnd,
+                                opt('timeFormat')
+                            );
+                        }
+                        else {
+                            text = formatDate(event.start, opt('timeFormat'));
+                        }
+                        timeElement.text(text);
+                        prevSnapDelta = snapDelta;
+                    }
+                },
+                stop: function (ev, ui) {
+                    trigger('eventResizeStop', this, event, ev, ui);
+                    if (snapDelta) {
+                        eventResize(
+                            this,
+                            event,
+                            eventEnd,
+                            ev,
+                            ui
+                        );
+                    }
+                    else {
+                        showEvents(event, eventElement);
+                        // BUG: if event was really short, need to put title back in span
+                    }
+                }
+            });
+        }
+
+
+    }
+
+    function DailyView(element, calendar, viewName) {
+        var t = this;
+
+
+        // exports
+        t.renderDailyView = renderDailyView;
+        t.setWidth = setWidth;
+        t.setHeight = setHeight;
+        t.afterRender = afterRender;
+        t.computeDateTop = computeDateTop;
+        t.getIsCellAllDay = getIsCellAllDay;
+        t.allDayRow = function () {
+            return allDayRow;
+        }; // badly named
+        t.getCoordinateGrid = function () {
+            return coordinateGrid;
+        }; // specifically for AgendaEventRenderer
+        t.getHoverListener = function () {
+            return hoverListener;
+        };
+        t.colLeft = colLeft;
+        t.colRight = colRight;
+        t.colContentLeft = colContentLeft;
+        t.colContentRight = colContentRight;
+        t.getDaySegmentContainer = function () {
+            return daySegmentContainer;
+        };
+        t.getSlotSegmentContainer = function () {
+            return slotSegmentContainer;
+        };
+        t.getSlotContainer = function () {
+            return slotContainer;
+        };
+        t.getRowCnt = function () {
+            return allDayRow.length;
+        };
+        t.getColCnt = function () {
+            return colCnt;
+        };
+        t.getColWidth = function () {
+            return colWidth;
+        };
+        t.getSnapHeight = function () {
+            return snapHeight;
+        };
+        t.getSnapDuration = function () {
+            return snapDuration;
+        };
+        t.getSlotHeight = function () {
+            return slotHeight;
+        };
+        t.getSlotDuration = function () {
+            return slotDuration;
+        };
+        t.getMinTime = function () {
+            return minTime;
+        };
+        t.getMaxTime = function () {
+            return maxTime;
+        };
+        t.defaultSelectionEnd = defaultSelectionEnd;
+        t.renderDayOverlay = renderDayOverlay;
+        t.renderSelection = renderSelection;
+        t.clearSelection = clearSelection;
+        t.reportDayClick = reportDayClick; // selection mousedown hack
+        t.dragStart = dragStart;
+        t.dragStop = dragStop;
+
+        t.setLevelValues = setLevelValues;
+        t.setLevelDetails = setLevelDetails;
+        t.getFullDayCount = getFullDayCount;
+        t.getLevelCount = getLevelCount;
+
+        // imports
+        View.call(t, element, calendar, viewName);
+        OverlayManager.call(t);
+        SelectionManager.call(t);
+        t.rangeToSegments = rangeToSegments;
+        ResourceEventRenderer.call(t);
+        var opt = t.opt;
+        var trigger = t.trigger;
+        var renderOverlay = t.renderOverlay;
+        var clearOverlays = t.clearOverlays;
+        var reportSelection = t.reportSelection;
+        var unselect = t.unselect;
+        //var daySelectionMousedown = t.daySelectionMousedown;
+        var slotSegHtml = t.slotSegHtml;
+        t.cellToDate = cellToDate;
+        //t.daySelectionMousedown = daySelectionMousedown;
+
+        var dateToCell = t.dateToCell;
+        //var rangeToSegments = t.rangeToSegments;
+        var formatDate = calendar.formatDate;
+        var calculateWeekNumber = calendar.calculateWeekNumber;
+
+
+        // locals
+
+        var resources = calendar.options.resources;
+        var dayTable;
+        var dayHead;
+        var dayHeadCells;
+        var dayBody;
+        var dayBodyCells;
+        var dayBodyCellInners;
+        var dayBodyCellContentInners;
+        var dayBodyFirstCell;
+        var dayBodyFirstCellStretcher;
+        var slotLayer;
+        var daySegmentContainer;
+        var allDayTable;
+        var allDayRow;
+        var slotScroller;
+        var slotContainer;
+        var slotSegmentContainer;
+        var slotTable;
+        var selectionHelper;
+
+        var viewWidth;
+        var viewHeight;
+        var axisWidth;
+        var colWidth;
+        var gutterWidth;
+
+        var slotDuration;
+        var slotHeight; // TODO: what if slotHeight changes? (see issue 650)
+
+        var snapDuration;
+        var snapRatio; // ratio of number of "selection" slots to normal slots. (ex: 1, 2, 4)
+        var snapHeight; // holds the pixel hight of a "selection" slot
+
+        var colCnt;
+        var slotCnt;
+        var coordinateGrid;
+        var hoverListener;
+        var colPositions;
+        var colContentPositions;
+        var slotTopCache = {};
+
+        var tm;
+        var rtl;
+        var minTime;
+        var maxTime;
+        var colFormat;
+
+
+        /* Rendering
+         -----------------------------------------------------------------------------*/
+
+
+        disableTextSelection(element.addClass('fc-agenda'));
+
+
+        function renderDailyView(c) {
+            colCnt = resources.length;
+            updateOptions();
+
+            if (!dayTable) { // first time rendering?
+                buildSkeleton(); // builds day table, slot area, events containers
+            }
+            else {
+                buildDayTable(); // rebuilds day table
+            }
+        }
+
+        function cellToDate() {
+            return t.start.clone().add('days', 0);
+        }
+
+        function setLevelValues(eventSegments, allDayLevelDetails) {
+            var newEvent = eventSegments[0];
+            var dateStr = newEvent.event.start.format("YYYY-MM-DD");
+            var row = newEvent.row;
+            var resourceId = newEvent.event.resourceId;
+            var levelObj = allDayLevelDetails[row][resourceId][dateStr];
+            var seg = newEvent;
+            var allDay = seg.event.allDay;
+            seg.fullDayCount = levelObj.fullDayCount;
+            seg.levelCount = levelObj.levelCount;
+            seg.level = levelObj.level;
+            seg.fullDayLevel = levelObj.fullDayLevel;
+            if (allDay == 'am' || allDay == 'pm') {
+                levelObj.level += 1;
+            } else {
+                levelObj.fullDayLevel += 1;
+            }
+            eventSegments[0] = seg;
+            return eventSegments;
+        }
+
+        function setLevelDetails(events) {
+            var levelDetails = [];
+            for (var i = 0; i < 2; i++) {
+                levelDetails[i] = [];
+                for (var resCnt = 0; resCnt < resources.length; resCnt++) {
+                    var resource = resources[resCnt];
+                    levelDetails[i][resource.id] = [];
+                    for (var j = 0; j < events.length; j++) {
+                        var dateString = events[j].start.format("YYYY-MM-DD");
+                        if (typeof levelDetails[i][resource.id][dateString] != "undefined") {
+                            continue;
+                        } else {
+                            var fullDayCount = getFullDayCount(resource.id, dateString, events);
+                            levelDetails[i][resource.id][dateString] = {levelCount: 0, level: 0, fullDayCount: fullDayCount};
+                        }
+                    }
+                }
+            }
+
+            for (var resCnt = 0; resCnt < resources.length; resCnt++) {
+                for (var i = 0; i < events.length; i++) {
+                    if (events[i].resourceId === resources[resCnt].id) {
+                        var resourceId = resources[resCnt].id;
+                        var newEvent = events[i];
+                        var dateString = newEvent.start.format("YYYY-MM-DD");
+                        for (var row = 0; row < 2; row++) {
+                            if (newEvent.allDay == 'fullday' || (row == 0 && newEvent.allDay == 'am') || (row == 1 && newEvent.allDay == 'pm')) {
+                                var levelCount = levelDetails[row][resourceId][dateString].levelCount + 1;
+                                var fullDayCount = levelDetails[row][resourceId][dateString].fullDayCount;
+                                levelDetails[row][resourceId][dateString] = {levelCount: levelCount, level: 0, fullDayCount: fullDayCount, fullDayLevel: 0};
+                            }
+                        }
+                    }
+                }
+
+            }
+            return levelDetails;
+        }
+
+        function getFullDayCount(resourceId, dateString, events) {
+            var count = 0;
+            for (var i = 0; i < events.length; i++) {
+                var newEvent = events[i];
+                var eventDate = newEvent.start.format("YYYY-MM-DD");
+                if (eventDate == dateString && newEvent.allDay == 'fullday' && newEvent.resourceId == resourceId) {
+                    count++;
+                }
+            }
+            return count;
+        }
+
+        function getLevelCount(event, allDayLevelDetails) {
+            var count = 0;
+            var eventDate = event.start.format("YYYY-MM-DD");
+            var resourceId = event.resourceId;
+            var levelObj1 = allDayLevelDetails[0][resourceId][eventDate];
+            var levelObj2 = allDayLevelDetails[1][resourceId][eventDate];
+            if (levelObj1.levelCount > levelObj2.levelCount) {
+                count = levelObj1.levelCount;
+            } else {
+                count = levelObj2.levelCount;
+            }
+            return count;
+        }
+
+        function rangeToSegments(start, end, allDay, resourceId) {
+
+            var rowCnt = (allDay) ? 1 : t.getRowCnt();
+            var colCnt = (allDay) ? 1 : t.getColCnt();
+            var segments = [];
+
+            var rangeDayOffsetStart = t.dateToDayOffset(start);
+            var rangeDayOffsetEnd = t.dateToDayOffset(end); // an exclusive value
+            var endTimeMS = +end.time();
+            if (endTimeMS && endTimeMS >= t.nextDayThreshold) {
+                rangeDayOffsetEnd++;
+            }
+            rangeDayOffsetEnd = Math.max(rangeDayOffsetEnd, rangeDayOffsetStart + 1);
+
+            var rangeCellOffsetFirst = t.dayOffsetToCellOffset(rangeDayOffsetStart);
+            var rangeCellOffsetLast = t.dayOffsetToCellOffset(rangeDayOffsetEnd) - 1;
+
+            for (var row = 0; row < rowCnt; row++) {
+
+                var rowCellOffsetFirst = row * colCnt;
+                var rowCellOffsetLast = rowCellOffsetFirst + colCnt - 1;
+
+                var segmentCellOffsetFirst = Math.max(rangeCellOffsetFirst, rowCellOffsetFirst);
+                var segmentCellOffsetLast = Math.min(rangeCellOffsetLast, rowCellOffsetLast);
+
+                if (segmentCellOffsetFirst <= segmentCellOffsetLast) {
+
+                    var segmentCellFirst = cellOffsetToCell(allDay, resourceId);
+                    var segmentCellLast = cellOffsetToCell(allDay, resourceId);
+
+                    var cols = [ segmentCellFirst.col, segmentCellLast.col ].sort();
+
+                    var isStart = t.cellOffsetToDayOffset(segmentCellOffsetFirst) == rangeDayOffsetStart;
+                    var isEnd = t.cellOffsetToDayOffset(segmentCellOffsetLast) + 1 == rangeDayOffsetEnd; // +1 for comparing exclusively
+
+                    if (allDay == 'pm') {
+                        row = 1;
+                    }
+                    segments.push({
+                        row: row,
+                        leftCol: cols[0],
+                        rightCol: cols[1],
+                        isStart: isStart,
+                        isEnd: isEnd
+                    });
+                }
+            }
+
+            return segments;
+        }
+
+        function cellOffsetToCell(allDay, resourceId) {
+            var row = 0;
+            var col = 0;
+            var colCnt = t.getColCnt();
+            if (allDay == 'pm') {
+                row = 1;
+            }
+
+            for (var colI = 0; colI < colCnt; colI++) {
+                if (resources[colI].id == resourceId) {
+                    col = colI;
+                }
+            }
+
+            return {
+                row: row,
+                col: col
+            };
+        }
+
+        function updateOptions() {
+
+            tm = opt('theme') ? 'ui' : 'fc';
+            rtl = opt('isRTL');
+            colFormat = opt('columnFormat');
+
+            minTime = moment.duration(opt('minTime'));
+            maxTime = moment.duration(opt('maxTime'));
+
+            slotDuration = moment.duration(opt('slotDuration'));
+            snapDuration = opt('snapDuration');
+            snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
+        }
+
+
+        /* Build DOM
+         -----------------------------------------------------------------------*/
+
+
+        function buildSkeleton() {
+            var s;
+            var headerClass = tm + "-widget-header";
+            var contentClass = tm + "-widget-content";
+            var slotTime;
+            var slotDate;
+            var minutes;
+            var slotNormal = slotDuration.asMinutes() % 15 === 0;
+
+            buildDayTable();
+
+            slotLayer =
+                $("<div style='position:absolute;z-index:2;left:0;width:100%'/>")
+                    .appendTo(element);
+
+            if (opt('allDaySlot')) {
+
+                daySegmentContainer =
+                    $("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
+                        .appendTo(slotLayer);
+
+                s =
+                    "<table style='width:100%' class='fc-agenda-allday' cellspacing='0'>" +
+                        "<tr>" +
+                        "<th class='" + headerClass + " fc-agenda-axis'>am</th>" +
+                        "<td>" +
+                        "<div class='fc-day-content'><div style='position:relative'/></div>" +
+                        "</td>" +
+                        "<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
+                        "</tr>" +
+                        "<tr>" +
+                        "<th class='" + headerClass + " fc-agenda-axis'>pm</th>" +
+                        "<td>" +
+                        "<div class='fc-day-content'><div style='position:relative'/></div>" +
+                        "</td>" +
+                        "<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
+                        "</tr>" +
+                        "</table>";
+                allDayTable = $(s).appendTo(slotLayer);
+                allDayRow = allDayTable.find('tr');
+
+                for (var rowCount = 0; rowCount < allDayRow.length; rowCount++) {
+                    dayBind($(allDayRow[rowCount]).find('td'));
+                }
+
+                slotLayer.append(
+                    "<div class='fc-agenda-divider " + headerClass + "'>" +
+                        "<div class='fc-agenda-divider-inner'/>" +
+                        "</div>"
+                );
+
+            } else {
+
+                daySegmentContainer = $([]); // in jQuery 1.4, we can just do $()
+
+            }
+
+            slotScroller =
+                $("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>")
+                    .appendTo(slotLayer);
+
+            slotContainer =
+                $("<div style='position:relative;width:100%;overflow:hidden'/>")
+                    .appendTo(slotScroller);
+
+            slotSegmentContainer =
+                $("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
+                    .appendTo(slotContainer);
+
+            s =
+                "<table class='fc-agenda-slots' style='width:100%' cellspacing='0'>" +
+                    "<tbody>";
+
+            slotTime = moment.duration(+minTime); // i wish there was .clone() for durations
+            slotCnt = 0;
+            while (slotTime < maxTime) {
+                slotDate = t.start.clone().time(slotTime); // will be in UTC but that's good. to avoid DST issues
+                minutes = slotDate.minutes();
+                s +=
+                    "<tr class='fc-slot" + slotCnt + ' ' + (!minutes ? '' : 'fc-minor') + "'>" +
+                        "<th class='fc-agenda-axis " + headerClass + "'>" +
+                        ((!slotNormal || !minutes) ?
+                            htmlEscape(formatDate(slotDate, opt('axisFormat'))) :
+                            '&nbsp;'
+                            ) +
+                        "</th>" +
+                        "<td class='" + contentClass + "'>" +
+                        "<div style='position:relative'>&nbsp;</div>" +
+                        "</td>" +
+                        "</tr>";
+                slotTime.add(slotDuration);
+                slotCnt++;
+            }
+
+            s +=
+                "</tbody>" +
+                    "</table>";
+
+            slotTable = $(s).appendTo(slotContainer);
+
+            slotBind(slotTable.find('td'));
+        }
+
+
+        /* Build Day Table
+         -----------------------------------------------------------------------*/
+
+
+        function buildDayTable() {
+            var html = buildDayTableHTML();
+
+            if (dayTable) {
+                dayTable.remove();
+            }
+            dayTable = $(html).appendTo(element);
+
+            dayHead = dayTable.find('thead');
+            dayHeadCells = dayHead.find('th').slice(1, -1); // exclude gutter
+            dayBody = dayTable.find('tbody');
+            dayBodyCells = dayBody.find('td').slice(0, -1); // exclude gutter
+            dayBodyCellInners = dayBodyCells.find('> div');
+            dayBodyCellContentInners = dayBodyCells.find('.fc-day-content > div');
+
+            dayBodyFirstCell = dayBodyCells.eq(0);
+            dayBodyFirstCellStretcher = dayBodyCellInners.eq(0);
+
+            markFirstLast(dayHead.add(dayHead.find('tr')));
+            markFirstLast(dayBody.add(dayBody.find('tr')));
+
+            // TODO: now that we rebuild the cells every time, we should call dayRender
+        }
+
+
+        function buildDayTableHTML() {
+            var html =
+                "<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'>" +
+                    buildDayTableHeadHTML() +
+                    buildDayTableBodyHTML() +
+                    "</table>";
+
+            return html;
+        }
+
+
+        function buildDayTableHeadHTML() {
+            var headerClass = tm + "-widget-header";
+            var date;
+            var html = '';
+            var weekText;
+            var col;
+
+            html +=
+                "<thead>" +
+                    "<tr>";
+
+            if (opt('weekNumbers')) {
+                date = cellToDate(0, 0);
+                weekText = calculateWeekNumber(date);
+                if (rtl) {
+                    weekText += opt('weekNumberTitle');
+                }
+                else {
+                    weekText = opt('weekNumberTitle') + weekText;
+                }
+                html +=
+                    "<th class='fc-agenda-axis fc-week-number " + headerClass + "'>" +
+                        htmlEscape(weekText) +
+                        "</th>";
+            }
+            else {
+                html += "<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
+            }
+
+            for (col = 0; col < colCnt; col++) {
+                date = cellToDate(0, col);
+                html +=
+                    "<th class='fc-" + dayIDs[date.day()] + " fc-col" + col + ' ' + headerClass + "'>" +
+                        htmlEscape(resources[col].name) +
+                        "</th>";
+            }
+
+            html +=
+                "<th class='fc-agenda-gutter " + headerClass + "'>&nbsp;</th>" +
+                    "</tr>" +
+                    "</thead>";
+
+            return html;
+        }
+
+
+        function buildDayTableBodyHTML() {
+            var headerClass = tm + "-widget-header"; // TODO: make these when updateOptions() called
+            var contentClass = tm + "-widget-content";
+            var date;
+            var today = calendar.getNow().stripTime();
+            var col;
+            var cellsHTML;
+            var cellHTML;
+            var classNames;
+            var html = '';
+
+            html +=
+                "<tbody>" +
+                    "<tr>" +
+                    "<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
+
+            cellsHTML = '';
+
+            for (col = 0; col < colCnt; col++) {
+
+                date = cellToDate(0, col);
+
+                classNames = [
+                    'fc-col' + col,
+                    'fc-' + dayIDs[date.day()],
+                    contentClass
+                ];
+                if (date.isSame(today, 'day')) {
+                    classNames.push(
+                        tm + '-state-highlight',
+                        'fc-today'
+                    );
+                }
+                else if (date < today) {
+                    classNames.push('fc-past');
+                }
+                else {
+                    classNames.push('fc-future');
+                }
+
+                cellHTML =
+                    "<td class='" + classNames.join(' ') + "'>" +
+                        "<div>" +
+                        "<div class='fc-day-content'>" +
+                        "<div style='position:relative'>&nbsp;</div>" +
+                        "</div>" +
+                        "</div>" +
+                        "</td>";
+
+                cellsHTML += cellHTML;
+            }
+
+            html += cellsHTML;
+            html +=
+                "<td class='fc-agenda-gutter " + contentClass + "'>&nbsp;</td>" +
+                    "</tr>" +
+                    "</tbody>";
+
+            return html;
+        }
+
+
+        // TODO: data-date on the cells
+
+
+        /* Dimensions
+         -----------------------------------------------------------------------*/
+
+
+        function setHeight(height) {
+            if (height === undefined) {
+                height = viewHeight;
+            }
+            viewHeight = height;
+            slotTopCache = {};
+
+            var headHeight = dayBody.position().top;
+            var allDayHeight = slotScroller.position().top; // including divider
+            var bodyHeight = Math.min( // total body height, including borders
+                height - headHeight,   // when scrollbars
+                slotTable.height() + allDayHeight + 1 // when no scrollbars. +1 for bottom border
+            );
+
+            dayBodyFirstCellStretcher
+                .height(bodyHeight - vsides(dayBodyFirstCell));
+
+            slotLayer.css('top', headHeight);
+
+            slotScroller.height(bodyHeight - allDayHeight - 1);
+
+            // the stylesheet guarantees that the first row has no border.
+            // this allows .height() to work well cross-browser.
+            var slotHeight0 = slotTable.find('tr:first').height() + 1; // +1 for bottom border
+            var slotHeight1 = slotTable.find('tr:eq(1)').height();
+            // HACK: i forget why we do this, but i think a cross-browser issue
+            slotHeight = (slotHeight0 + slotHeight1) / 2;
+
+            snapRatio = slotDuration / snapDuration;
+            snapHeight = slotHeight / snapRatio;
+        }
+
+
+        function setWidth(width) {
+            viewWidth = width;
+            colPositions.clear();
+            colContentPositions.clear();
+
+            var axisFirstCells = dayHead.find('th:first');
+            if (allDayTable) {
+                axisFirstCells = axisFirstCells.add(allDayTable.find('th:first'));
+            }
+            axisFirstCells = axisFirstCells.add(slotTable.find('th:first'));
+
+            axisWidth = 0;
+            setOuterWidth(
+                axisFirstCells
+                    .width('')
+                    .each(function (i, _cell) {
+                        axisWidth = Math.max(axisWidth, $(_cell).outerWidth());
+                    }),
+                axisWidth
+            );
+
+            var gutterCells = dayTable.find('.fc-agenda-gutter');
+            if (allDayTable) {
+                gutterCells = gutterCells.add(allDayTable.find('th.fc-agenda-gutter'));
+            }
+
+            var slotTableWidth = slotScroller[0].clientWidth; // needs to be done after axisWidth (for IE7)
+
+            gutterWidth = slotScroller.width() - slotTableWidth;
+            if (gutterWidth) {
+                setOuterWidth(gutterCells, gutterWidth);
+                gutterCells
+                    .show()
+                    .prev()
+                    .removeClass('fc-last');
+            } else {
+                gutterCells
+                    .hide()
+                    .prev()
+                    .addClass('fc-last');
+            }
+
+            colWidth = Math.floor((slotTableWidth - axisWidth) / colCnt);
+            setOuterWidth(dayHeadCells.slice(0, -1), colWidth);
+        }
+
+
+        /* Scrolling
+         -----------------------------------------------------------------------*/
+
+
+        function resetScroll() {
+            var top = computeTimeTop(
+                moment.duration(opt('scrollTime'))
+            ) + 1; // +1 for the border
+
+            function scroll() {
+                slotScroller.scrollTop(top);
+            }
+
+            scroll();
+            setTimeout(scroll, 0); // overrides any previous scroll state made by the browser
+        }
+
+
+        function afterRender() { // after the view has been freshly rendered and sized
+            resetScroll();
+        }
+
+
+        /* Slot/Day clicking and binding
+         -----------------------------------------------------------------------*/
+
+
+        function dayBind(cells) {
+            cells.click(slotClick)
+                .mousedown(daySelectionMousedown);
+        }
+
+
+        function slotBind(cells) {
+            cells.click(slotClick)
+                .mousedown(slotSelectionMousedown);
+        }
+
+
+        function slotClick(ev) {
+            if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
+                var col = Math.min(colCnt - 1, Math.floor((ev.pageX - dayTable.offset().left - axisWidth) / colWidth));
+                var date = cellToDate(0, col);
+                var match = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
+                if (match) {
+                    var slotIndex = parseInt(match[1], 10);
+                    date.add(minTime + slotIndex * slotDuration);
+                    date = calendar.rezoneDate(date);
+                    trigger(
+                        'dayClick',
+                        dayBodyCells[col],
+                        date,
+                        ev
+                    );
+                } else {
+                    trigger(
+                        'dayClick',
+                        dayBodyCells[col],
+                        date,
+                        ev
+                    );
+                }
+            }
+        }
+
+
+        /* Semi-transparent Overlay Helpers
+         -----------------------------------------------------*/
+        // TODO: should be consolidated with BasicView's methods
+
+
+        function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid, cells) { // overlayEnd is exclusive
+
+            if (refreshCoordinateGrid) {
+                coordinateGrid.build();
+            }
+            if (!cells) {
+                return;
+            }
+            var resourceId = resources[cells[0].col].id;
+            var segments = rangeToSegments(overlayStart, overlayEnd, false, resourceId);
+
+            var row1, row2;
+            if (cells[0].row == cells[1].row) {
+                row1 = row2 = cells[0].row;
+            } else {
+                if (cells[0].row > cells[1].row) {
+                    row1 = cells[1].row;
+                    row2 = cells[0].row;
+                } else {
+                    row1 = cells[0].row;
+                    row2 = cells[1].row;
+                }
+            }
+
+            for (var i = 0; i < segments.length; i++) {
+                var segment = segments[i];
+                dayBind(
+                    renderCellOverlay(
+                        row1,
+                        segment.leftCol,
+                        row2,
+                        segment.rightCol
+                    )
+                );
+            }
+        }
+
+
+        function renderCellOverlay(row0, col0, row1, col1) { // only for all-day?
+            var rect = coordinateGrid.rect(row0, col0, row1, col1, slotLayer);
+            return renderOverlay(rect, slotLayer);
+        }
+
+
+        function renderSlotOverlay(overlayStart, overlayEnd) {
+
+            // normalize, because dayStart/dayEnd have stripped time+zone
+            overlayStart = overlayStart.clone().stripZone();
+            overlayEnd = overlayEnd.clone().stripZone();
+
+            for (var i = 0; i < colCnt; i++) { // loop through the day columns
+
+                var dayStart = cellToDate(0, i);
+                var dayEnd = dayStart.clone().add('days', 1);
+
+                var stretchStart = dayStart < overlayStart ? overlayStart : dayStart; // the max of the two
+                var stretchEnd = dayEnd < overlayEnd ? dayEnd : overlayEnd; // the min of the two
+
+                if (stretchStart < stretchEnd) {
+                    var rect = coordinateGrid.rect(0, i, 0, i, slotContainer); // only use it for horizontal coords
+                    var top = computeDateTop(stretchStart, dayStart);
+                    var bottom = computeDateTop(stretchEnd, dayStart);
+
+                    rect.top = top;
+                    rect.height = bottom - top;
+                    slotBind(
+                        renderOverlay(rect, slotContainer)
+                    );
+                }
+            }
+        }
+
+
+        /* Coordinate Utilities
+         -----------------------------------------------------------------------------*/
+
+
+        coordinateGrid = new CoordinateGrid(function (rows, cols) {
+            var e, n, p;
+            dayHeadCells.each(function (i, _e) {
+                e = $(_e);
+                n = e.offset().left;
+                if (i) {
+                    p[1] = n;
+                }
+                p = [n];
+                cols[i] = p;
+            });
+            p[1] = n + e.outerWidth();
+            if (opt('allDaySlot')) {
+                e = allDayRow;
+                for (var allDayRowCount = 0; allDayRowCount < e.length; allDayRowCount++) {
+                    n = $(e[allDayRowCount]).offset().top;
+                    rows[allDayRowCount] = [n, n + e.outerHeight()];
+                }
+            }
+            var slotTableTop = slotContainer.offset().top;
+            var slotScrollerTop = slotScroller.offset().top;
+            var slotScrollerBottom = slotScrollerTop + slotScroller.outerHeight();
+
+            function constrain(n) {
+                return Math.max(slotScrollerTop, Math.min(slotScrollerBottom, n));
+            }
+
+            for (var i = 0; i < slotCnt * snapRatio; i++) { // adapt slot count to increased/decreased selection slot count
+                rows.push([
+                    constrain(slotTableTop + snapHeight * i),
+                    constrain(slotTableTop + snapHeight * (i + 1))
+                ]);
+            }
+        });
+
+
+        hoverListener = new HoverListener(coordinateGrid);
+
+        colPositions = new HorizontalPositionCache(function (col) {
+            return dayBodyCellInners.eq(col);
+        });
+
+        colContentPositions = new HorizontalPositionCache(function (col) {
+            return dayBodyCellContentInners.eq(col);
+        });
+
+
+        function colLeft(col) {
+            return colPositions.left(col);
+        }
+
+
+        function colContentLeft(col) {
+            return colContentPositions.left(col);
+        }
+
+
+        function colRight(col) {
+            return colPositions.right(col);
+        }
+
+
+        function colContentRight(col) {
+            return colContentPositions.right(col);
+        }
+
+
+        // NOTE: the row index of these "cells" doesn't correspond to the slot index, but rather the "snap" index
+
+
+        function getIsCellAllDay(cell) { // TODO: remove because mom.hasTime() from realCellToDate() is better
+            return opt('allDaySlot') && (cell.row == 0 || cell.row == 1);
+        }
+
+
+        function realCellToDate(cell) { // ugh "real" ... but blame it on our abuse of the "cell" system
+            var date = cellToDate(0, cell.col);
+            var snapIndex = cell.row;
+
+            if (opt('allDaySlot')) {
+                snapIndex = snapIndex - 2;
+            }
+
+            if (snapIndex >= 0) {
+                date.time(moment.duration(minTime + snapIndex * snapDuration));
+                date = calendar.rezoneDate(date);
+            }
+
+            return date;
+        }
+
+
+        function computeDateTop(date, startOfDayDate) {
+            return computeTimeTop(
+                moment.duration(
+                    date.clone().stripZone() - startOfDayDate.clone().stripTime()
+                )
+            );
+        }
+
+
+        function computeTimeTop(time) { // time is a duration
+
+            if (time < minTime) {
+                return 0;
+            }
+            if (time >= maxTime) {
+                return slotTable.height();
+            }
+
+            var slots = (time - minTime) / slotDuration;
+            var slotIndex = Math.floor(slots);
+            var slotPartial = slots - slotIndex;
+            var slotTop = slotTopCache[slotIndex];
+
+            // find the position of the corresponding <tr>
+            // need to use this tecnhique because not all rows are rendered at same height sometimes.
+            if (slotTop === undefined) {
+                slotTop = slotTopCache[slotIndex] =
+                    slotTable.find('tr').eq(slotIndex).find('td div')[0].offsetTop;
+                // .eq() is faster than ":eq()" selector
+                // [0].offsetTop is faster than .position().top (do we really need this optimization?)
+                // a better optimization would be to cache all these divs
+            }
+
+            var top =
+                slotTop - 1 + // because first row doesn't have a top border
+                    slotPartial * slotHeight; // part-way through the row
+
+            top = Math.max(top, 0);
+
+            return top;
+        }
+
+
+        /* Selection
+         ---------------------------------------------------------------------------------*/
+
+
+        function defaultSelectionEnd(start) {
+            if (start.hasTime()) {
+                return start.clone().add(slotDuration);
+            }
+            else {
+                return start.clone().add('days', 1);
+            }
+        }
+
+
+        function renderSelection(start, end, cells) {
+            if (start.hasTime() || end.hasTime()) {
+                renderSlotSelection(start, end);
+            }
+            else if (opt('allDaySlot')) {
+                renderDayOverlay(start, end, true, cells); // true for refreshing coordinate grid
+            }
+        }
+
+
+        function renderSlotSelection(startDate, endDate, col) {
+            var helperOption = opt('selectHelper');
+            coordinateGrid.build();
+            if (helperOption) {
+                if (col >= 0 && col < colCnt) { // only works when times are on same day
+                    var rect = coordinateGrid.rect(0, col, 0, col, slotContainer); // only for horizontal coords
+                    var top = computeDateTop(startDate, startDate);
+                    var bottom = computeDateTop(endDate, startDate);
+                    if (bottom > top) { // protect against selections that are entirely before or after visible range
+                        rect.top = top;
+                        rect.height = bottom - top;
+                        rect.left += 2;
+                        rect.width -= 5;
+                        if ($.isFunction(helperOption)) {
+                            var helperRes = helperOption(startDate, endDate);
+                            if (helperRes) {
+                                rect.position = 'absolute';
+                                selectionHelper = $(helperRes)
+                                    .css(rect)
+                                    .appendTo(slotContainer);
+                            }
+                        } else {
+                            rect.isStart = true; // conside rect a "seg" now
+                            rect.isEnd = true;   //
+                            selectionHelper = $(slotSegHtml(
+                                {
+                                    title: '',
+                                    start: startDate,
+                                    end: endDate,
+                                    className: ['fc-select-helper'],
+                                    editable: false
+                                },
+                                rect
+                            ));
+                            selectionHelper.css('opacity', opt('dragOpacity'));
+                        }
+                        if (selectionHelper) {
+                            slotBind(selectionHelper);
+                            slotContainer.append(selectionHelper);
+                            setOuterWidth(selectionHelper, rect.width, true); // needs to be after appended
+                            setOuterHeight(selectionHelper, rect.height, true);
+                        }
+                    }
+                }
+            } else {
+                renderSlotOverlay(startDate, endDate);
+            }
+        }
+
+
+        function clearSelection() {
+            clearOverlays();
+            if (selectionHelper) {
+                selectionHelper.remove();
+                selectionHelper = null;
+            }
+        }
+
+        function daySelectionMousedown(ev) { // not really a generic manager method, oh well
+            var cellToDate = t.cellToDate;
+            var getIsCellAllDay = t.getIsCellAllDay;
+            var hoverListener = t.getHoverListener();
+            var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
+            var cells = [];
+
+            if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
+                unselect(ev);
+                var dates;
+                hoverListener.start(function (cell, origCell) { // TODO: maybe put cellToDate/getIsCellAllDay info in cell
+                    clearSelection();
+                    if (cell && getIsCellAllDay(cell)) {
+                        cells = [cell, origCell];
+                        var newCell = {row: 0, col: cell.col};
+                        var newOrigCell = {row: 0, col: origCell.col};
+                        dates = [ cellToDate(newCell), cellToDate(newOrigCell) ].sort(dateCompare);
+                        renderSelection(
+                            dates[0],
+                            dates[1].clone().add('days', 1), cells // make exclusive
+                        );
+                    } else {
+                        dates = null;
+                    }
+                }, ev);
+                $(document).one('mouseup', function (ev) {
+                    hoverListener.stop();
+                    if (dates) {
+                        if (+dates[0] == +dates[1]) {
+                            reportDayClick(dates[0], ev);
+                        }
+                        var alldayValue = 'fullday';
+                        var resourceId = resources[cells[0].col].id;
+                        if (cells[0].row == cells[1].row) {
+                            alldayValue = (cells[0].row == 0) ? 'am' : 'pm';
+                        }
+                        reportSelection(
+                            dates[0],
+                            dates[1].clone().add('days', 1), // make exclusive
+                            ev, alldayValue, resourceId
+                        );
+                    }
+                });
+            }
+        }
+
+        function slotSelectionMousedown(ev) {
+            if (ev.which == 1 && opt('selectable')) { // ev.which==1 means left mouse button
+                unselect(ev);
+                var dates;
+                var resourceId;
+                hoverListener.start(function (cell, origCell) {
+                    clearSelection();
+                    if (cell && cell.col == origCell.col && !getIsCellAllDay(cell)) {
+                        var d1 = realCellToDate(origCell);
+                        var d2 = realCellToDate(cell);
+                        resourceId = resources[cell.col].id;
+                        dates = [
+                            d1,
+                            d1.clone().add(snapDuration), // calculate minutes depending on selection slot minutes
+                            d2,
+                            d2.clone().add(snapDuration)
+                        ].sort(dateCompare);
+                        renderSlotSelection(dates[0], dates[3], cell.col);
+                    } else {
+                        dates = null;
+                    }
+                }, ev);
+                $(document).one('mouseup', function (ev) {
+                    hoverListener.stop();
+                    if (dates) {
+                        if (+dates[0] == +dates[1]) {
+                            reportDayClick(dates[0], ev);
+                        }
+                        reportSelection(dates[0], dates[3], ev, false, resourceId);
+                    }
+                });
+            }
+        }
+
+
+        function reportDayClick(date, ev) {
+            trigger('dayClick', dayBodyCells[dateToCell(date).col], date, ev);
+        }
+
+
+        /* External Dragging
+         --------------------------------------------------------------------------------*/
+
+
+        function dragStart(_dragElement, ev, ui) {
+            hoverListener.start(function (cell) {
+                clearOverlays();
+                if (cell) {
+                    var d1 = realCellToDate(cell);
+                    var d2 = d1.clone();
+                    if (d1.hasTime()) {
+                        d2.add(calendar.defaultTimedEventDuration);
+                        renderSlotOverlay(d1, d2);
+                    }
+                    else {
+                        d2.add(calendar.defaultAllDayEventDuration);
+                        renderDayOverlay(d1, d2);
+                    }
+                }
+            }, ev);
+        }
+
+
+        function dragStop(_dragElement, ev, ui) {
+            var cell = hoverListener.stop();
+            clearOverlays();
+            if (cell) {
+                trigger(
+                    'drop',
+                    _dragElement,
+                    realCellToDate(cell),
+                    ev,
+                    ui
+                );
+            }
+        }
+
+
+    }
+
+    function ResourceEventRenderer() {
+        var t = this;
+
+
+        // exports
+        t.renderEvents = renderEvents;
+        t.clearEvents = clearEvents;
+        t.slotSegHtml = slotSegHtml;
+
+
+        // imports
+        DayEventRenderer.call(t);
+        var opt = t.opt;
+        var trigger = t.trigger;
+        var isEventDraggable = t.isEventDraggable;
+        var isEventResizable = t.isEventResizable;
+        var eventElementHandlers = t.eventElementHandlers;
+        var setHeight = t.setHeight;
+        var getDaySegmentContainer = t.getDaySegmentContainer;
+        var getSlotSegmentContainer = t.getSlotSegmentContainer;
+        var getHoverListener = t.getHoverListener;
+        var computeDateTop = t.computeDateTop;
+        var getIsCellAllDay = t.getIsCellAllDay;
+        var colContentLeft = t.colContentLeft;
+        var colContentRight = t.colContentRight;
+        var cellToDate = t.cellToDate;
+        var getColCnt = t.getColCnt;
+        var getColWidth = t.getColWidth;
+        var getSnapHeight = t.getSnapHeight;
+        var getSnapDuration = t.getSnapDuration;
+        var getSlotHeight = t.getSlotHeight;
+        var getSlotDuration = t.getSlotDuration;
+        var getSlotContainer = t.getSlotContainer;
+        var reportEventElement = t.reportEventElement;
+        var showEvents = t.showEvents;
+        var hideEvents = t.hideEvents;
+        var eventDrop = t.eventDrop;
+        var eventResize = t.eventResize;
+        var renderDayOverlay = t.renderDayOverlay;
+        var clearOverlays = t.clearOverlays;
+        var renderDayEvents = t.renderDayEvents;
+        var getMinTime = t.getMinTime;
+        var getMaxTime = t.getMaxTime;
+        var calendar = t.calendar;
+        var formatDate = calendar.formatDate;
+        var formatRange = calendar.formatRange;
+        var getEventEnd = calendar.getEventEnd;
+        var resources = t.calendar.options.resources;
+
+
+        // overrides
+        t.draggableDayEvent = draggableDayEvent;
+
+
+        /* Rendering
+         ----------------------------------------------------------------------------*/
+
+
+        function renderEvents(events, modifiedEventId) {
+            var i, len = events.length,
+                dayEvents = [],
+                slotEvents = [];
+            for (i = 0; i < len; i++) {
+                if (events[i].allDay) {
+                    dayEvents.push(events[i]);
+                } else {
+                    slotEvents.push(events[i]);
+                }
+            }
+
+            if (opt('allDaySlot')) {
+                renderDayEvents(dayEvents, modifiedEventId);
+                setHeight(); // no params means set to viewHeight
+            }
+
+            renderSlotSegs(compileSlotSegs(slotEvents), modifiedEventId);
+        }
+
+
+        function clearEvents() {
+            getDaySegmentContainer().empty();
+            getSlotSegmentContainer().empty();
+        }
+
+
+        function compileSlotSegs(events) {
+            var colCnt = getColCnt(),
+                minTime = getMinTime(),
+                maxTime = getMaxTime(),
+                cellDate,
+                i,
+                j, seg,
+                colSegs,
+                segs = [];
+
+            for (i = 0; i < colCnt; i++) {
+                cellDate = cellToDate(0, 0);
+                var resourceId = resources[i].id;
+
+                colSegs = sliceSegs(
+                    events,
+                    cellDate.clone().time(minTime),
+                    cellDate.clone().time(maxTime), resourceId
+                );
+
+                colSegs = placeSlotSegs(colSegs); // returns a new order
+
+                for (j = 0; j < colSegs.length; j++) {
+                    seg = colSegs[j];
+                    seg.col = i;
+                    segs.push(seg);
+                }
+            }
+
+            return segs;
+        }
+
+
+        function sliceSegs(events, rangeStart, rangeEnd, resourceId) {
+
+            // normalize, because all dates will be compared w/o zones
+            rangeStart = rangeStart.clone().stripZone();
+            rangeEnd = rangeEnd.clone().stripZone();
+
+            var segs = [],
+                i, len = events.length, event,
+                eventStart, eventEnd,
+                segStart, segEnd,
+                isStart, isEnd;
+            for (i = 0; i < len; i++) {
+
+                event = events[i];
+
+                // get dates, make copies, then strip zone to normalize
+                eventStart = event.start.clone().stripZone();
+                eventEnd = getEventEnd(event).stripZone();
+
+                if (eventEnd > rangeStart && eventStart < rangeEnd && event.resourceId == resourceId) {
+
+                    if (eventStart < rangeStart) {
+                        segStart = rangeStart.clone();
+                        isStart = false;
+                    }
+                    else {
+                        segStart = eventStart;
+                        isStart = true;
+                    }
+
+                    if (eventEnd > rangeEnd) {
+                        segEnd = rangeEnd.clone();
+                        isEnd = false;
+                    }
+                    else {
+                        segEnd = eventEnd;
+                        isEnd = true;
+                    }
+
+                    segs.push({
+                        event: event,
+                        start: segStart,
+                        end: segEnd,
+                        isStart: isStart,
+                        isEnd: isEnd
+                    });
+                }
+            }
+
+            return segs.sort(compareSlotSegs);
+        }
+
+
+        // renders events in the 'time slots' at the bottom
+        // TODO: when we refactor this, when user returns `false` eventRender, don't have empty space
+        // TODO: refactor will include using pixels to detect collisions instead of dates (handy for seg cmp)
+
+        function renderSlotSegs(segs, modifiedEventId) {
+
+            var i, segCnt = segs.length, seg,
+                event,
+                top,
+                bottom,
+                columnLeft,
+                columnRight,
+                columnWidth,
+                width,
+                left,
+                right,
+                html = '',
+                eventElements,
+                eventElement,
+                triggerRes,
+                titleElement,
+                height,
+                slotSegmentContainer = getSlotSegmentContainer(),
+                isRTL = opt('isRTL');
+
+            // calculate position/dimensions, create html
+            for (i = 0; i < segCnt; i++) {
+                seg = segs[i];
+                event = seg.event;
+                top = computeDateTop(seg.start, seg.start);
+                bottom = computeDateTop(seg.end, seg.start);
+                columnLeft = colContentLeft(seg.col);
+                columnRight = colContentRight(seg.col);
+                columnWidth = columnRight - columnLeft;
+
+                // shave off space on right near scrollbars (2.5%)
+                // TODO: move this to CSS somehow
+                columnRight -= columnWidth * .025;
+                columnWidth = columnRight - columnLeft;
+
+                width = columnWidth * (seg.forwardCoord - seg.backwardCoord);
+
+                if (opt('slotEventOverlap')) {
+                    // double the width while making sure resize handle is visible
+                    // (assumed to be 20px wide)
+                    width = Math.max(
+                        (width - (20 / 2)) * 2,
+                        width // narrow columns will want to make the segment smaller than
+                        // the natural width. don't allow it
+                    );
+                }
+
+                if (isRTL) {
+                    right = columnRight - seg.backwardCoord * columnWidth;
+                    left = right - width;
+                }
+                else {
+                    left = columnLeft + seg.backwardCoord * columnWidth;
+                    right = left + width;
+                }
+
+                // make sure horizontal coordinates are in bounds
+                left = Math.max(left, columnLeft);
+                right = Math.min(right, columnRight);
+                width = right - left;
+
+                seg.top = top;
+                seg.left = left;
+                seg.outerWidth = width;
+                seg.outerHeight = bottom - top;
+                html += slotSegHtml(event, seg);
+            }
+
+            slotSegmentContainer[0].innerHTML = html; // faster than html()
+            eventElements = slotSegmentContainer.children();
+
+            // retrieve elements, run through eventRender callback, bind event handlers
+            for (i = 0; i < segCnt; i++) {
+                seg = segs[i];
+                event = seg.event;
+                eventElement = $(eventElements[i]); // faster than eq()
+                triggerRes = trigger('eventRender', event, event, eventElement);
+                if (triggerRes === false) {
+                    eventElement.remove();
+                } else {
+                    if (triggerRes && triggerRes !== true) {
+                        eventElement.remove();
+                        eventElement = $(triggerRes)
+                            .css({
+                                position: 'absolute',
+                                top: seg.top,
+                                left: seg.left
+                            })
+                            .appendTo(slotSegmentContainer);
+                    }
+                    seg.element = eventElement;
+                    if (event._id === modifiedEventId) {
+                        bindSlotSeg(event, eventElement, seg);
+                    } else {
+                        eventElement[0]._fci = i; // for lazySegBind
+                    }
+                    reportEventElement(event, eventElement);
+                }
+            }
+
+            lazySegBind(slotSegmentContainer, segs, bindSlotSeg);
+
+            // record event sides and title positions
+            for (i = 0; i < segCnt; i++) {
+                seg = segs[i];
+                if ((eventElement = seg.element)) {
+                    seg.vsides = vsides(eventElement, true);
+                    seg.hsides = hsides(eventElement, true);
+                    titleElement = eventElement.find('.fc-event-title');
+                    if (titleElement.length) {
+                        seg.contentTop = titleElement[0].offsetTop;
+                    }
+                }
+            }
+
+            // set all positions/dimensions at once
+            for (i = 0; i < segCnt; i++) {
+                seg = segs[i];
+                if ((eventElement = seg.element)) {
+                    eventElement[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
+                    height = Math.max(0, seg.outerHeight - seg.vsides);
+                    eventElement[0].style.height = height + 'px';
+                    event = seg.event;
+                    if (seg.contentTop !== undefined && height - seg.contentTop < 10) {
+                        // not enough room for title, put it in the time (TODO: maybe make both display:inline instead)
+                        eventElement.find('div.fc-event-time')
+                            .text(
+                                formatDate(event.start, opt('timeFormat')) + ' - ' + event.title
+                            );
+                        eventElement.find('div.fc-event-title')
+                            .remove();
+                    }
+                    trigger('eventAfterRender', event, event, eventElement);
+                }
+            }
+
+        }
+
+
+        function slotSegHtml(event, seg) {
+            var html = "<";
+            var url = event.url;
+            var skinCss = getSkinCss(event, opt);
+            var classes = ['fc-event', 'fc-event-vert'];
+            if (isEventDraggable(event)) {
+                classes.push('fc-event-draggable');
+            }
+            if (seg.isStart) {
+                classes.push('fc-event-start');
+            }
+            if (seg.isEnd) {
+                classes.push('fc-event-end');
+            }
+            classes = classes.concat(event.className);
+            if (event.source) {
+                classes = classes.concat(event.source.className || []);
+            }
+            if (url) {
+                html += "a href='" + htmlEscape(event.url) + "'";
+            } else {
+                html += "div";
+            }
+
+            html +=
+                " class='" + classes.join(' ') + "'" +
+                    " style=" +
+                    "'" +
+                    "position:absolute;" +
+                    "top:" + seg.top + "px;" +
+                    "left:" + seg.left + "px;" +
+                    skinCss +
+                    "'" +
+                    ">" +
+                    "<div class='fc-event-inner'>" +
+                    "<div class='fc-event-time'>";
+
+            if (event.end) {
+                html += htmlEscape(formatRange(event.start, event.end, opt('timeFormat')));
+            } else {
+                html += htmlEscape(formatDate(event.start, opt('timeFormat')));
+            }
+
+            html +=
+                "</div>" +
+                    "<div class='fc-event-title'>" +
+                    htmlEscape(event.title || '') +
+                    "</div>" +
+                    "</div>" +
+                    "<div class='fc-event-bg'></div>";
+
+            if (seg.isEnd && isEventResizable(event)) {
+                html +=
+                    "<div class='ui-resizable-handle ui-resizable-s'>=</div>";
+            }
+            html +=
+                "</" + (url ? "a" : "div") + ">";
+            return html;
+        }
+
+
+        function bindSlotSeg(event, eventElement, seg) {
+            var timeElement = eventElement.find('div.fc-event-time');
+            if (isEventDraggable(event)) {
+                draggableSlotEvent(event, eventElement, timeElement);
+            }
+            if (seg.isEnd && isEventResizable(event)) {
+                resizableSlotEvent(event, eventElement, timeElement);
+            }
+            eventElementHandlers(event, eventElement);
+        }
+
+
+        /* Dragging
+         -----------------------------------------------------------------------------------*/
+
+
+        // when event starts out FULL-DAY
+        // overrides DayEventRenderer's version because it needs to account for dragging elements
+        // to and from the slot area.
+
+        function draggableDayEvent(event, eventElement, seg) {
+            var isStart = seg.isStart;
+            var origWidth;
+            var revert;
+            var allDay = event.allDay;
+            var dayDelta;
+
+            var hoverListener = getHoverListener();
+            var colWidth = getColWidth();
+            var minTime = getMinTime();
+            var slotDuration = getSlotDuration();
+            var slotHeight = getSlotHeight();
+            var snapDuration = getSnapDuration();
+            var snapHeight = getSnapHeight();
+
+            eventElement.draggable({
+                opacity: opt('dragOpacity', 'month'), // use whatever the month view was using
+                revertDuration: opt('dragRevertDuration'),
+                start: function (ev, ui) {
+
+                    trigger('eventDragStart', eventElement, event, ev, ui);
+                    hideEvents(event, eventElement);
+                    origWidth = eventElement.width();
+
+                    hoverListener.start(function (cell, origCell) {
+                        clearOverlays();
+                        if (cell) {
+                            revert = false;
+
+                            var origDate = cellToDate(0, origCell.col);
+                            var date = cellToDate(0, cell.col);
+                            dayDelta = 1;//date.diff(origDate, 'days');
+
+                            if (cell == null) { // on full-days
+
+                                var cells = [cell, origCell];
+                                renderDayOverlay(
+                                    event.start.clone().add('days', dayDelta),
+                                    getEventEnd(event).add('days', dayDelta), false, cells
+                                );
+
+                                resetElement();
+                            }
+                            else { // mouse is over bottom slots
+
+                                if (isStart) {
+                                    if (cell.row != 1 && cell.row != 0) {
+                                        // convert event to temporary slot-event
+                                        eventElement.width(colWidth - 10); // don't use entire width
+                                        setOuterHeight(eventElement, calendar.defaultTimedEventDuration / slotDuration * slotHeight); // the default height
+                                        eventElement.draggable('option', 'grid', [ colWidth, 1 ]);
+                                        allDay = false;
+                                    }
+                                }
+                                else {
+                                    revert = true;
+                                }
+                            }
+
+                            revert = revert || (allDay && !dayDelta);
+                        }
+                        else {
+                            resetElement();
+                            revert = true;
+                        }
+
+                        eventElement.draggable('option', 'revert', revert);
+
+                    }, ev, 'drag');
+                },
+                stop: function (ev, ui) {
+                    var cell = hoverListener.stop();
+                    clearOverlays();
+                    trigger('eventDragStop', eventElement, event, ev, ui);
+
+                    if (revert) { // hasn't moved or is out of bounds (draggable has already reverted)
+
+                        resetElement();
+                        eventElement.css('filter', ''); // clear IE opacity side-effects
+                        showEvents(event, eventElement);
+                    }
+                    else { // changed!
+
+                        var eventStart = event.start.clone().add('days', 0); // already assumed to have a stripped time
+                        var snapTime;
+                        var snapIndex;
+                        event.resourceId = resources[cell.col].id;
+                        if (cell.row != 1 && cell.row != 0) {
+                            snapIndex = Math.round((eventElement.offset().top - getSlotContainer().offset().top) / snapHeight); // why not use ui.offset.top?
+                            snapTime = moment.duration(minTime + snapIndex * snapDuration);
+                            eventStart = calendar.rezoneDate(eventStart.clone().time(snapTime));
+                        } else {
+                            var allDay = event.allDay;
+                            if (allDay != 'fullday') {
+                                if (cell.row) {
+                                    allDay = 'pm';
+                                } else {
+                                    allDay = 'am';
+                                }
+                            }
+                            event._allDay = true;
+                            event.allDay = allDay;
+                        }
+
+                        eventDrop(
+                            this, // el
+                            event,
+                            eventStart,
+                            ev,
+                            ui
+                        );
+                    }
+                }
+            });
+            function resetElement() {
+                if (!allDay) {
+                    eventElement
+                        .width(origWidth)
+                        .height('')
+                        .draggable('option', 'grid', null);
+                    allDay = true;
+                }
+            }
+        }
+
+
+        // when event starts out IN TIMESLOTS
+
+        function draggableSlotEvent(event, eventElement, timeElement) {
+            var coordinateGrid = t.getCoordinateGrid();
+            var colCnt = getColCnt();
+            var colWidth = getColWidth();
+            var snapHeight = getSnapHeight();
+            var snapDuration = getSnapDuration();
+
+            // states
+            var origPosition; // original position of the element, not the mouse
+            var origCell;
+            var isInBounds, prevIsInBounds;
+            var isAllDay, prevIsAllDay;
+            var colDelta, prevColDelta;
+            var dayDelta; // derived from colDelta
+            var snapDelta, prevSnapDelta; // the number of snaps away from the original position
+
+            // newly computed
+            var eventStart, eventEnd;
+            var cell;
+
+            eventElement.draggable({
+                scroll: false,
+                grid: [ colWidth, snapHeight ],
+                axis: colCnt == 1 ? 'y' : false,
+                opacity: opt('dragOpacity'),
+                revertDuration: opt('dragRevertDuration'),
+                start: function (ev, ui) {
+
+                    trigger('eventDragStart', eventElement, event, ev, ui);
+                    hideEvents(event, eventElement);
+
+                    coordinateGrid.build();
+
+                    // initialize states
+                    origPosition = eventElement.position();
+                    origCell = coordinateGrid.cell(ev.pageX, ev.pageY);
+                    isInBounds = prevIsInBounds = true;
+                    isAllDay = prevIsAllDay = getIsCellAllDay(origCell);
+                    colDelta = prevColDelta = 0;
+                    dayDelta = 0;
+                    snapDelta = prevSnapDelta = 0;
+
+                    eventStart = null;
+                    eventEnd = null;
+                },
+                drag: function (ev, ui) {
+
+                    // NOTE: this `cell` value is only useful for determining in-bounds and all-day.
+                    // Bad for anything else due to the discrepancy between the mouse position and the
+                    // element position while snapping. (problem revealed in PR #55)
+                    //
+                    // PS- the problem exists for draggableDayEvent() when dragging an all-day event to a slot event.
+                    // We should overhaul the dragging system and stop relying on jQuery UI.
+                    cell = coordinateGrid.cell(ev.pageX, ev.pageY);
+
+                    // update states
+                    isInBounds = !!cell;
+                    if (isInBounds) {
+                        isAllDay = getIsCellAllDay(cell);
+
+                        // calculate column delta
+                        colDelta = Math.round((ui.position.left - origPosition.left) / colWidth);
+                        if (colDelta != prevColDelta) {
+                            // calculate the day delta based off of the original clicked column and the column delta
+                            var origDate = cellToDate(0, origCell.col);
+                            var col = origCell.col + colDelta;
+                            col = Math.max(0, col);
+                            col = Math.min(colCnt - 1, col);
+                            var date = cellToDate(0, col);
+                            dayDelta = date.diff(origDate, 'days');
+                        }
+
+                        // calculate minute delta (only if over slots)
+                        if (!isAllDay) {
+                            snapDelta = Math.round((ui.position.top - origPosition.top) / snapHeight);
+                        }
+                    }
+
+                    // any state changes?
+                    if (
+                        isInBounds != prevIsInBounds ||
+                            isAllDay != prevIsAllDay ||
+                            colDelta != prevColDelta ||
+                            snapDelta != prevSnapDelta
+                        ) {
+
+                        // compute new dates
+                        if (isAllDay) {
+                            eventStart = event.start.clone().stripTime().add('days', 0);
+                            eventEnd = eventStart.clone().add(calendar.defaultAllDayEventDuration);
+                            renderDayOverlay(eventStart, eventEnd, false, [cell, cell]);
+                            isInBounds = true;
+                        }
+                        else {
+                            eventStart = event.start.clone().add(snapDelta * snapDuration).add('days', 0);
+                            eventEnd = getEventEnd(event).add(snapDelta * snapDuration).add('days', 0);
+                        }
+
                         updateUI();
+
+                        // update previous states for next time
+                        prevIsInBounds = isInBounds;
+                        prevIsAllDay = isAllDay;
+                        prevColDelta = colDelta;
+                        prevSnapDelta = snapDelta;
+                    }
+
+                    // if out-of-bounds, revert when done, and vice versa.
+                    eventElement.draggable('option', 'revert', !isInBounds);
+
+                },
+                stop: function (ev, ui) {
+                    clearOverlays();
+                    if (cell) {
+                        event.resourceId = resources[cell.col].id;
+                        if (cell.row == 0 || cell.row == 1) {
+                            var allDayVal = false;
+                            if (cell.row) {
+                                allDayVal = 'pm';
+                            } else {
+                                allDayVal = 'am';
+                            }
+                            event._allDay = true;
+                            event.allDay = allDayVal;
+                        }
+                    }
+                    trigger('eventDragStop', eventElement, event, ev, ui);
+                    if (isInBounds && (isAllDay || dayDelta || snapDelta)) { // changed!
+                        eventDrop(
+                            this, // el
+                            event,
+                            eventStart,
+                            ev,
+                            ui
+                        );
+                    }
+                    else { // either no change or out-of-bounds (draggable has already reverted)
+
+                        // reset states for next time, and for updateUI()
+                        isInBounds = true;
+                        isAllDay = false;
+                        colDelta = 0;
+                        dayDelta = 0;
+                        snapDelta = 0;
+
+                        updateUI();
                         eventElement.css('filter', ''); // clear IE opacity side-effects
 
                         // sometimes fast drags make event revert to wrong position, so reset.
@@ -5263,7 +8163,6 @@
 
     }
 
-
     /* Agenda Event Segment Utilities
      -----------------------------------------------------------------------------*/
 
@@ -5806,6 +8705,7 @@
                 col = row.col;
                 row = row.row;
             }
+
             var cellOffset = row * colCnt + (col * dis + dit); // column, adjusted for RTL (dis & dit)
 
             return cellOffset;
@@ -5882,9 +8782,9 @@
         // - isStart
         // - isEnd
         //
-        function rangeToSegments(start, end) {
+        function rangeToSegments(start, end, allDay) {
 
-            var rowCnt = t.getRowCnt();
+            var rowCnt = (allDay) ? 1 : t.getRowCnt();
             var colCnt = t.getColCnt();
             var segments = []; // array of segments to return
 
@@ -5930,6 +8830,9 @@
                     var isStart = cellOffsetToDayOffset(segmentCellOffsetFirst) == rangeDayOffsetStart;
                     var isEnd = cellOffsetToDayOffset(segmentCellOffsetLast) + 1 == rangeDayOffsetEnd; // +1 for comparing exclusively
 
+                    if (allDay == 'pm') {
+                        row = 1;
+                    }
                     segments.push({
                         row: row,
                         leftCol: cols[0],
@@ -5992,7 +8895,11 @@
         var getEventEnd = calendar.getEventEnd;
         var formatDate = calendar.formatDate;
 
+        var setLevelValues = t.setLevelValues;
+        var setLevelDetails = t.setLevelDetails;
+        var getLevelCount = t.getLevelCount;
 
+
         // Render `events` onto the calendar, attach mouse event handlers, and call the `eventAfterRender` callback for each.
         // Mouse event will be lazily applied, except if the event has an ID of `modifiedEventId`.
         // Can only be called when the event container is empty (because it wipes out all innerHTML).
@@ -6116,21 +9023,26 @@
 
 
         // Generate an array of "segments" for all events.
+        var allDayLevelDetails = [];
+
         function buildSegments(events) {
             var segments = [];
+            allDayLevelDetails = setLevelDetails(events);
             for (var i = 0; i < events.length; i++) {
                 var eventSegments = buildSegmentsForEvent(events[i]);
+                if (eventSegments.length) {
+                    eventSegments = setLevelValues(eventSegments, allDayLevelDetails);
+                }
                 segments.push.apply(segments, eventSegments); // append an array to an array
             }
             return segments;
         }
 
-
         // Generate an array of segments for a single event.
         // A "segment" is the same data structure that View.rangeToSegments produces,
         // with the addition of the `event` property being set to reference the original event.
         function buildSegmentsForEvent(event) {
-            var segments = rangeToSegments(event.start, getEventEnd(event));
+            var segments = rangeToSegments(event.start, getEventEnd(event), event.allDay, event.resourceId);
             for (var i = 0; i < segments.length; i++) {
                 segments[i].event = event;
             }
@@ -6155,8 +9067,19 @@
 
                 var left = leftFunc(segment.leftCol);
                 var right = rightFunc(segment.rightCol);
-                segment.left = left;
-                segment.outerWidth = right - left;
+                var level = parseInt(segment.fullDayCount) + segment.level;
+                var levelCount = segment.levelCount;
+                if (segment.event.allDay == 'fullday') {
+                    level = segment.fullDayLevel;
+                    levelCount = getLevelCount(segment.event, allDayLevelDetails);
+                }
+                var eventCount = parseInt(segment.fullDayCount) + parseInt(levelCount);
+                var outerWidth = right - left - 5;
+                var eventWidth = outerWidth / eventCount;
+
+
+                segment.left = left + (eventWidth * parseInt(level));
+                segment.outerWidth = eventWidth;
             }
         }
 
@@ -6180,6 +9103,12 @@
             var isRTL = opt('isRTL');
             var event = segment.event;
             var url = event.url;
+            var rowContentElements = getRowContentElements();
+            var rowContentElement = rowContentElements[0];
+            var elementHeight = $(rowContentElement[1]).position().top - $(rowContentElement[0]).position().top - 4;
+            if (event.allDay == 'fullday') {
+                elementHeight *= 2;
+            }
 
             // generate the list of CSS classNames
             var classNames = [ 'fc-event', 'fc-event-hori' ];
@@ -6215,6 +9144,7 @@
                     "'" +
                     "position:absolute;" +
                     "left:" + segment.left + "px;" +
+                    "height:" + elementHeight + "px;" +
                     skinCss +
                     "'" +
                     ">" +
@@ -6303,7 +9233,7 @@
             // Set each row's height by setting height of first inner div
             if (doRowHeights) {
                 for (i = 0; i < rowContentElements.length; i++) {
-                    rowContentElements[i].height(rowContentHeights[i]);
+                    //rowContentElements[i].height(rowContentHeights[i]);
                 }
             }
 
@@ -6310,8 +9240,9 @@
             // Get each row's top, relative to the views's origin.
             // Important to do this after setting each row's height.
             for (i = 0; i < rowContentElements.length; i++) {
+                var alldayRows = rowContentElements[i];
                 rowContentTops.push(
-                    rowContentElements[i].position().top
+                    $(alldayRows[i]).position().top
                 );
             }
 
@@ -6362,7 +9293,7 @@
 
                     // adjust the columns to account for the segment's height
                     for (colI = segment.leftCol; colI <= segment.rightCol; colI++) {
-                        colHeights[colI] = segment.top + segment.outerHeight;
+                        colHeights[colI] = segment.top;// + segment.outerHeight * segment.row;
                     }
                 }
 
@@ -6673,7 +9604,156 @@
 
     }
 
+    fcViews.agendaList = agendaListView;
+    function agendaListView(element, calendar, viewName) {
+        var t = this;
+        t.resources = calendar.options.resources;
 
+        function dayClick(ev) {
+        }
+
+        function trigger(name, thisObj) {
+        }
+
+        // exports
+        t.render = render;
+
+        t.setHeight = setHeight;
+        t.setWidth = setWidth;
+
+        t.renderEvents = renderEvents;
+
+        // pseudo method...
+        t.unselect = function () {
+        };
+
+        t.clearEvents = clearEvents;
+        //another way to write pseudo method
+        function clearEvents() {
+        }
+
+        function setHeight(height, dateChanged) {
+        }
+
+        function setWidth(width) {
+        }
+
+        // imports
+        View.call(t, element, calendar, 'agendaList');
+        var opt = t.opt;
+
+        //var renderAgenda = t.renderAgenda;
+        var formatDate = calendar.formatDate;
+
+        function sortEvent(a, b) {
+            return a.start - b.start;
+        }
+
+        function render(date, delta) {
+            if (delta) {
+                addDays(date, delta);
+                if (!opt('weekends')) {
+                    skipWeekend(date, delta < 0 ? -1 : 1);
+                }
+            }
+            var start = date.clone();
+            var end = start.add('days', 1);
+
+            t.title = formatDate(date, opt('titleFormat'));
+            t.start = t.intervalStart = start;
+            t.end = t.intervalEnd = end;
+        }
+
+        function eventsOfThisDay(events, theDate) {
+            var retArr = new Array();
+            for (i in events) {
+                if (events[i].start.format('YYYY-MM-DD') == theDate.format('YYYY-MM-DD')) {
+                    retArr.push(events[i]);
+                }
+            }
+            return retArr;
+        }
+
+        function getListDateString(event) {
+            var ret = "";
+            if (event.allDay) { //all day event
+                ret = event.allDay;
+            }
+            else {
+                ret = formatDate(event.start, 'LT') + " - " + formatDate(event.end, 'LT'); // You can change format here
+            }
+            return ret;
+        }
+
+        function renderEvents(events, modifiedEventId) {
+            var sortedEvents = events.sort(sortEvent);
+            var resources = calendar.options.resources;
+
+            var x = "<table class='fc-list-table'>";
+            var hasEvents = false;
+            var total = sortedEvents.length;
+            if (total > 0) {
+                var start = sortedEvents[0].start.clone();
+                var dateVar = start.clone();
+                var end = sortedEvents[total - 1].start.clone();
+                while (dateVar <= end) {
+                    var arr = eventsOfThisDay(sortedEvents, dateVar);
+                    if (arr.length > 0) {
+                        hasEvents = true;
+                        x += "<thead><tr><th colspan='4' class='fc-list-date'><span>";
+                        x += formatDate(dateVar, 'll');
+                        x += "</span></th></tr></thead>";
+                        for (var resCnt = 0; resCnt < resources.length; resCnt++) {
+                            var includeHeader = true;
+                            for (i in arr) {
+                                if (arr[i].resourceId == resources[resCnt].id) {
+                                    if (includeHeader) {
+                                        x += "<tr><td colspan='4' class='diary-engineer-name'><b>" + resources[resCnt].name + "</b></td></tr>";
+                                        includeHeader = false;
+                                    }
+                                    x += "<tr><td>&nbsp;</td><td class='fc-list-time'>";
+                                    x += getListDateString(arr[i]);
+                                    x += "</td><td>&nbsp;</td>";
+                                    x += "<td class='fc-list-event'>";
+                                    x += "<span id='list" + arr[i].id;
+                                    var classtemp = "' class='fc-list-event " + arr[i].className + "'>";
+                                    x += classtemp.replace(",", " "); //Avoid className is array
+                                    x += arr[i].title;
+                                    x += "</span></td></tr>";
+                                }
+                            }
+                        }
+                    }
+                    dateVar = dateVar.add('days', 1);
+                }
+            }
+            if (!hasEvents) {
+                x += "<tr><td colspan='4'>There is no events</td></tr>";
+            }
+            x += "</table>";
+
+            $('.fc-view-agendaList').html(x);
+        }
+
+        function rerenderEvents(modifiedEventId) {
+        }
+
+
+    }
+
+    setDefaults({
+        titleFormat: {
+            list: ''
+        },
+        columnFormat: {
+            list: 'll'
+        },
+        buttonText: {
+            list: 'List'
+        }
+    });
+
+
     /* Generalized Segment Utilities
      -------------------------------------------------------------------------------------------------*/
 
@@ -6783,9 +9863,9 @@
         }
 
 
-        function reportSelection(start, end, ev) {
+        function reportSelection(start, end, ev, allDay, resourceId) {
             selected = true;
-            trigger('select', null, start, end, ev);
+            trigger('select', null, start, end, allDay, resourceId);
         }
 
 
@@ -6794,6 +9874,7 @@
             var getIsCellAllDay = t.getIsCellAllDay;
             var hoverListener = t.getHoverListener();
             var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
+            var cells = [];
 
             if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
                 unselect(ev);
@@ -6801,10 +9882,13 @@
                 hoverListener.start(function (cell, origCell) { // TODO: maybe put cellToDate/getIsCellAllDay info in cell
                     clearSelection();
                     if (cell && getIsCellAllDay(cell)) {
-                        dates = [ cellToDate(origCell), cellToDate(cell) ].sort(dateCompare);
+                        cells = [cell, origCell];
+                        var newCell = {row: 0, col: cell.col};
+                        var newOrigCell = {row: 0, col: origCell.col};
+                        dates = [ cellToDate(newCell), cellToDate(newOrigCell) ].sort(dateCompare);
                         renderSelection(
                             dates[0],
-                            dates[1].clone().add('days', 1) // make exclusive
+                            dates[1].clone().add('days', 1), cells // make exclusive
                         );
                     } else {
                         dates = null;
@@ -6816,10 +9900,14 @@
                         if (+dates[0] == +dates[1]) {
                             reportDayClick(dates[0], ev);
                         }
+                        var alldayValue = 'fullday';
+                        if (cells[0].row == cells[1].row) {
+                            alldayValue = (cells[0].row == 0) ? 'am' : 'pm';
+                        }
                         reportSelection(
                             dates[0],
                             dates[1].clone().add('days', 1), // make exclusive
-                            ev
+                            ev, alldayValue
                         );
                     }
                 });
